---
title: "컴퓨터 아키텍처와 운영체제"
date: 2025-04-01 19:20:00 +/-TTTT
categories: [Book, 한 권으로 읽는 컴퓨터 구조와 프로그래밍]
tags: [CS]
math: true
toc: true
# pin: true
---
# 개요
컴퓨터는 더 빠른 속도와 적은 전력, 편한 프로그래밍을 위해 개선해가는 과정에서 설계가 그만큼 복잡해졌고, 이 과정에서 컴퓨터의 여러 구성요소를 배치하는 방법인 컴퓨터 아키텍처가 등장했다.  
  
## 기본적인 구조 요소들
가장 기본적인 컴퓨터 구조는 폰 노이만 구조와 하버드 구조가 있고, 둘의 차이는 메모리 배열뿐이다. 폰 노이만 구조는 동시에 명령어와 데이터를 메모리에서 가져올 수 없기 때문에 상대적으로 더 느리고, 하버드 구조는 동시에 가져올 수 있어서 빠르지만 두 번째 메모리를 처리하기 위한 버스가 더 필요하다.  
  
### 프로세서 코어
- 폰 노이만 구조와 하버드 구조는 CPU가 하나인 구조다.
- 여러 CPU를 활용할 수 있는 멀티 프로세서 시스템이 생겼지만, 병렬화 문제가 발생했다.
- 반도체 회로 크기가 줄어들면서 비용도 낮아졌고, 생산 속도가 증가했다.
- CPU의 성능도 향상되었다.
- 하지만, 크기가 작아지고 성능은 올라가면서 단위 면적당 열 발생은 증가했다.
- 이로 인해 전력 장벽 문제가 발생했다.
- 최근에는 CPU의 정의가 프로세서 코어라는 것으로 바꼈다.
- 여러 개의 CPU가 들어가는 것을 멀티코어 프로세서라고 한다.  
  
### 마이크로프로세서와 마이크로 컴퓨터
- 물리적인 패키징에 따라 구조를 구분할 수도 있다.
- 마이크로프로세서 : 메모리와 I/O가 프로세서 코어와 같은 패키지가 아닌 프로세서다.
- 마이크로컴퓨터(마이크로컨트롤러) : 모든 요소를 한 칩 안에 패키징한 것이다.
- 일반적으로 마이크로프로세서보다 마이크로 컴퓨터가 덜 강력하다.
- 마이크로프로세서는 큰 시스템의 부품에, 마이크로컴퓨터는 식기세척기 등에서 사용되는 작은 컴퓨터다.  
- 단일 칩 시스템 : 더 복잡한 마이크로컴퓨터로, 간단합 온칩 I/O를 제공하지만, WiFi 회로 등 복잡한 장치가 들어있다.  
  
## 프로시저, 서브루틴, 함수
- 중복된 코드를 줄이면 코드가 메모리를 덜 차지하고, 코드 수정 시 작업할 양이 줄어든다.
- 함수 = 프로시저 = 서브루틴 = 재사용 수단
- 함수를 재사용하기 위해서는 호출한 곳에서 함수 실행 후 원래 자리로 돌아와야 한다.
- 이때 어디서 함수를 호출했는지를 기억하는 위치가 프로그램 카운터의 값이다.
  
## 스택
- 함수는 다른 함수 혹은 자기 자신을
- 재귀 : 함수가 자기 자신을 호출하는 것
- 재귀나 트리처럼 한 수준을 내려갈 때마다 돌아올 위치를 기억해야 한다.
- 스택을 사용해 함수 호출 때마다 자신이 돌아갈 반환 주소를 저장한다.
- 대부분의 하드웨어는 그래서 스택을 지원한다.
- 소프트웨어로 스택 오버플로를 검사하지 않아도 괜찮게 돕는 한계 레지스터가 있다.
- 또한 스택은 각각의 함수 호출이 독립적이게 하기 위해 지역 변수도 같이 저장한다.
- 이렇게 스택에 저장되는 정보들의 집합을 스택 프레임이라고 한다.
  
## 인터럽트
- 폴링 : CPU가 특정 장치나 자원의 상태를 지속적으로 확인하여 서비스가 필요한지 판단하는 방식
- 해당 방식은 CPU 자원을 많이 소모하고, 불필요한 대기가 많다.
- 인터럽트 : 외부에서 CPU에 신호를 보내 작업 중단 후, 즉시 처리해야 할 이벤트를 알려주는 방식
- 해당 방식은 필요한 경우에만 작업을 중단해서 효율적이고, 실시간 상황에 맞게 처리가 가능하다.
- 하지만 구현이 복잡하고, 우선순위 관리를 잘해줘야 한다.
- 최근 프로세서 대부분은 인터럽트 시스템이 들어간다.
- 통합 주변장치(온칩 I/O 장치)가 많은 프로세서 칩에 들어가 내부 인터럽트 시스템과 연결된다.
- 주변장치가 인터럽트 요청을 생성하면, 프로세서는 현재 실행 중인 프로그램을 잠시 멈춘다.
- 인터럽트 핸들러를 실행시켜 필요한 작업을 처리한 후에, 이전에 실행 중이던 프로그램을 재시작한다.
- 이때 인터럽트 서비스 후 돌아오기 위해 필요한 정보들도 마찬가지로 스택에 저장한다.
- 인터럽트 핸들러 주소를 저장하기 위한 메모리 주소가 존재한다.
- 각 주소에는 여러 인터럽트 백터가 들어있어 인터럽트 핸들러 주소를 지정한다.
- 인터럽트를 중단시킬 수도 있는 마스크라는 것도 있다.
- 인터럽트가 많은 경우에는 우선순위가 있어서 높은 인터럽트부터 처리한다.
- 운영체제에서는 가상 인터럽트나 소프트웨어 인터럽트를 제공한다.
- 이는 일반 프로그램들은 접근할 수 없는 물리적 인터럽트에 접근할 수 있게한다.
- 유닉스의 시그널, 최근 시스템들의 이벤트 같은 것들이 이에 해당한다.
  
## 상대 주소 지정
- 여러 프로그램을 동시에 실행할 수 있게 프로그램간 전환을 관리하는 것이 운영체제 혹은 커널이다.
- 시분할 : 프로그램의 실행 시간을 조절하는 스케줄링 기법
- 시간을 정해진 간격으로 나눈 후, 정해진 시간 간격 동안 프로그램을 실행한다.
- 프로그램을 메모리로 불러들이는데 시간이 걸려 해당 방식은 느리다.
- 각 프로그램에게 각기 다른 공간을 허용한다면 빠르게 할 수 있다.
- 절대 주소 지정은 재배치가 불가능해 다른 번지에서 프로그램 실행이 안되서 유연성이 떨어진다.
- 인덱스 레지스터는 들어있는 값과 명령어의 주소와 더해 유효 주소를 계산한다.
- 상대 주소 지정은 명령어의 주소를 기준으로 하는 상대적인 주소로 해석한다.
- 그래서 프로그램을 메모리의 원하는 위치로 자유롭게 재배치가 용이하다.
  
## 메모리 관리 장치(MMU)
- 프로그램간 간섭 문제를 해결하기 위해 MMU가 등장했다.
- MMU가 포함된 시스템은 가상 주소와 물리 주소를 구분한다.
- 프로그램은 가상 주소를 사용하고, MMU는 가상 주소를 물리 주소로 변환한다.
- MMU는 가상 메모리 주소를 두 부분으로 나눈다.
- 주소의 하위는 물리적 주소 범위와 같다.
- 상위 부분은 페이지 테이블이라는 RAM 영역을 통해 주소를 변환한다.
- CPU가 가상 주소를 생성해 MMU에 전달하면, MMU가 페이지 테이블을 참조해 가상 주소를 물리 주소로 변환하고, 물리 주소를 기반으로 데이터에 접근하거나 연산을 수행한다.
- 물리적으로 연속적이 아니라도, 논리적으로 연속된 공간처럼 사용할 수 있다.
  
## 가상 메모리
- 운영체는 MMU를 사용해 프로그램에게 가상 메모리를 제공한다.
- 페이지 폴트 매커니즘으로 인해 프로그램은 필요한만큼 많은 메모리가 있는줄 안다.
- 요청 받은 메모리가 실제 사용 가능한 메모리보다 크다면 스왑 아웃을 한다.
- 이는 현재 불필요한 메모리 페이지를 대용량 장치인 디스크로 옮기는 작업이다.
- 스왑 아웃한 페이지 접근 시 스왑 인을 통해 다시 메모리로 불러들인다.
- 이런 방식을 요구불 페이징이라고 한다.
- 스와핑 작업은 시스템 성능 저하에 영향이 크다.
- 그래서 이런 성능 저하를 막기 위해 최근에는 LRU 알고리즘을 사용하기도 한다.
- 이는 최근에 가장 자주 사용된 페이지는 메모리에 남기고, 덜 사용된걸 스왑 아웃한다.
  
## 시스템 공간과 사용자 공간
- 사용자 프로그램이 타이머 설정을 변경하거나, MMU의 설정을 변경할 수 있다면 문제가 발생한다.
- 이를 해결하기 위해 CPU에는 컴퓨터가 시스템 모드인지 사용자 모드인지 결정하는 비트가 레지스터에 있다.
- I/O 처리 명령어 등의 특권 명령어는 시스템 모드에서만 실행가능하다.
- 트랩이나 시스템 콜 같은 명령어를 통해 사용자 모드의 프로그램이 시스템 모드 프로그램(OS)에 요청을 보낼 수도 있다.
- 해당 방식을 통해 사용자 프로그램으로부터 운영체제를 보호하고, 사용자 프로그램 간 보호하며, 운영체제만 전적으로 자원 할당을 제어할 수 있다.
  
## 메모리 계층과 성능
- 속도는 CPU가 가장 빠르고, 그 뒤는 메모리와 디스크 순서다.
- 이는 CPU가 아무리 빨라도 메모리를 기다려야 한다는 것이다.
- 이를 해결하기 위해 CPU에 캐시라는 아주 빠른 온칩 메모리를 추가했다.
- 캐시는 용량은 작지만 빨라서, 프로세서와 같은 속도로 작동한다.
- 프로그램이 사용하는 데이터는 보통 한 곳에 모여 있다.
- 이를 활용해 CPU 메모리 컨트롤러는 메모리에서 연속된 열에 있는 데이터를 한 번에 가져온다.
- CPU가 캐시에서 필요한 데이터를 못찾아 메모리를 읽는 경우를 캐시 미스, 반대 경우를 캐시 히트라고 한다.
- 같은 칩 안의 캐시 메모리라도 CPU에서 멀어질수록 캐시가 느려지고 커진다.
- CPU에서 가까운 순서대로 레지스터, L1, L2, L3, 주 메모리, 디스크 순서다.
- 븐기 예측 회로는 조건 분기 명령어 결과를 예측해 프로 페치한다.
- 순서를 벗어나는 실행을 처리하는 회로도 존재해서, 명령어 순서를 벗어나 더 효율적으로 명령어를 수행할 수 있게 해준다.
- 캐시 일관성을 유지하기 위해 데이터를 캐시에 기록하면서 동시에 메모리에도 기록하는 라이트 스루라는 방법이 있는데, 이 방식은 캐시 사용의 장점 대부분을 없앤다.
  
## 코프로세서
- 더 단순한 회로인 코프로세서에 몇 가지 연산을 위임한다.
- 그러면 프로세서 코어는 일반적인 연산에 활용할 수 있는 공간을 확보할 수 있다.
- 일부 코프로세서는 다른 일은 하지 않고 메모리와 디스크 사이의 데이터 복사만 담당한다.
- 이런 방식을 직접 메모리 접근이라고 한다.
- CPU는 이런 DMA 장치에 귀찮은 일들으 떠맡겨 유용한 연산을 더 많이 처리할 수 있다.
  
## 메모리상의 데이터 배치
- 메모리에 담기는 데이터는 정적 데이터다.
- 프로그램 작성시 얼마나 많은 메모리가 필요한지 알고 있다는 의미다.
- 폰 노이만 배치에서는 명령어가 같은 메모리에 존재하고, 하버드 배치에서는 별도로 존재한다.
- 프로그램은 실행 전에 크기를 알 수 없는 동적 데이터도 다룬다.
- 동적 데이터는 힙 영역에 쌓인다.
- 힙은 위로 쌓이고, 스택은 아래로 쌓인다.
- 힙과 스택이 서로 충돌하지 않게 잘 배치 해야한다.
  
## 프로그램 실행
- 프로그램에는 첫 번째 명령어가 위치한 주소인 진입점이 있다.
- 하지만 실제로 제일 먼저 실행되는 명령어는 런타임 라이브러리에 있는 명령어다.
- 런타임 라이브러리는 메모리 설정을 책임져서 스택과 힙 영역을 설정하는 역할을 수행한다.
- 또한 정적 데이터에 위치한 데이터의 초깃값도 설정한다.
  
## 메모리 전력 소비
- 데이터를 메모리에서 이리저리 옮기려면 전력이 소비된다.
- 데스크탑은 괜찮지만, 모바일에서는 전력 소비가 중요하다.
- 데이터 센터에는 컴퓨터가 엄청 많기 때문에 적은 전력 소비가 합쳐셔 많이 클 수도 있다.
  
# 후기
이번 주 범위는 적어서 쉽게 읽었는데 확실히 지난 내용들에서 배웠던 부분들이 자주 나오니 머리에 남아있지 않아서 당황스럽다...  
  
나중에 한 번 날을 잡아서 처음부터 간단하게 정리를 다시 해봐야겠다.