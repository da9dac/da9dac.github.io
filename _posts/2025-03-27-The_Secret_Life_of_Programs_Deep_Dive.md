---
title: "Deep Dive"
date: 2025-03-27 20:40:00 +/-TTTT
categories: [Book, 한 권으로 읽는 컴퓨터 구조와 프로그래밍]
tags: [CS]
math: true
toc: true
# pin: true
---
## 3주차
### 프로그램이 실행되는 과정
책을 보다 데이터 경로와 제어 신호 부분에서 큰 이미지 자료가 딱 나오자마자 눈과 뇌가 받아들이질 못해서 직접 찾아봤다...  
  
#### 초기화
1. 프로그램 코드와 초기 데이터가 메모리에 저장된다.
2. 프로그램 카운터가 실행할 첫 번째 메모리 주소를 가리킨다.
3. 주소 버스를 통해 프로그램 카운터가 가리키는 주소를 메모리에 전달한다.
4. 데이터 버스를 통해 해당 주소에서 명령어를 가져와 CPU로 전달한다.
5. 명령어 레지스터에 가져온 명령어를 저장한다.
  
#### 명령어 사이클 : FETCH
1. 프로그램 카운터가 현재 실행할 명령어의 메모리 주소를 카리킨다.
2. 주소 버스 &rarr; 메모리 &rarr; 데이터 버스 &rarr; CPU &rarr; 명령어 레지스터
3. 프로그램 카운터가 다음 명령어를 가리키게 증가한다.
   
#### 명령어 사이클 : DECODE
1. 명령어 레지스터에 저장된 명령어를 디코딩해 어떤 작업을 수행할지 결정한다.
2. 피보나치의 경우 이전과 현재 값을 더해 다음 값을 계산한다 같은 작업 내용을 얻는다.
  
#### 데이터 읽기 및 연산 준비
1. 간접 주소 레지스터에서 계산에 필요한 데이터를 저장한 메모리 주소를 간접적으로 참조한다.
2. 주소 버스를 통해 간접 주소 레지스터가 가리키는 메모리 주소에 데이터를 요청한다.
3. 데이터 버스를 통해 메모리에서 데이터를 읽고 누산기에 올린다.
  
#### 연산 수행
1. ALU가 연산을 수행한다.
2. 연산 결과를 누산기에 저장한다.
3. 연산 결과에 따라 조건 코드 레지스터에 플래그를 설정한다.  
  
플래그는 오버플로 발생 여부 같은 것을 의미한다.
  
#### 결과 저장
1. 계산된 값을 데이터 버스를 통해 다시 메모리에 저장한다.
2. 현재 계산된 값을 다음 피보나치 수 계산에 다시 사용할 수 있도록 메모리나 레지스터에 저장한다.
  
#### 반복 및 종료
1. 프로그램 카운터가 다음 명령어로 이동하여 반복적으로 피보나치 값을 계산한다.
2. 종료 조건이 충족될 때까지 반복하고 종료한다.

#### 요약
1. 프로그램 카운터가 명령어를 가져온다
2. 명령어 레지스터에서 이를 해석하고, 필요한 데이터를 메모리에서 읽는다.
3. ALU가 연산을 수행하고 결과를 누산기에 저장한다.
4. 결과는 메모리에 기록되고, 조건 코드 레지스터가 상태를 업데이트한다.
5. 위 과정을 종료 조건까지 반복한다.
  
### 비트 플래그
정수의 각 비트를 상태를 나타내는 플래그로 사용하는 기법으로, 여러 상태를 하나의 변수로 관리할 수 있다.  
  
#### 사용자 권한 관리
사용자 권한이 다음과 같이 있을 때때
- 0001(1) : 읽기
- 0010(2) : 쓰기
- 0100(4) : 실행
- 1000(8) : 관리
  
권한 설정
```python
permissions = 0

permissions |= 1
permissions |= 2

print(bin(permissions))  # 출력: 0b11 (읽기 + 쓰기)
``` 
  
권한 확인
```python
if permissions & 2:  
    print("쓰기 권한 있음")
else:
    print("쓰기 권한 없음")
```
  
권한 제거 (and not)
```python
permissions &= ~2  

print(bin(permissions))  # 출력: 0b1 (읽기)
```
  
여러 권한 확인
```python
permissions = 1 | 2 | 4  

print(bin(permissions))  # 출력: 0b111 (읽기 + 쓰기 + 실행)
```
  
플래그 설정 = 왼쪽 시프트 연산
```python
# 읽기 권한 플래그 설정 (1번째 비트)
READ_PERMISSION = 1 << 0  # 1

# 쓰기 권한 플래그 설정 (2번째 비트)
WRITE_PERMISSION = 1 << 1  # 2

# 실행 권한 플래그 설정 (3번째 비트)
EXECUTE_PERMISSION = 1 << 2  # 4
```
  
플래그 확인 = 오른쪽 시프트 연산
```python
permissions = READ_PERMISSION | WRITE_PERMISSION  # 3 (0b11)

if (permissions >> 1) & 1:
    print("쓰기 권한 있음")
else:
    print("쓰기 권한 없음")

```
  
플래그 해제
```python
permissions &= ~(1 << 1)  # 1 (0b1)

print(bin(permissions))  # 0b1 (읽기 권한만 남음)
```
  
[관련 SQL 문제](https://school.programmers.co.kr/learn/courses/30/lessons/301647)

### GPU와 비트코인
비트 코인을 채굴할 때는 블록체인 네트워크에서 해시 함수를 반복적으로 계산해 블록을 유효화 하는 작업이 필요하고, 해당 과정에서 많은 수의 단순한 연산이 필요하다.  
  
GPU는 단순한 ALU 수백 수천 개를 내장하고, 병렬 처리에 특화되어 있기 때문에 이러한 부분에서 CPU보다 훨씬 더 많은 연산을 동시에 처리할 수 있어서 채굴에 사용되었다.
  
## 4주차
### 복잡도와 지역성
시간 복잡도는 알고리즘 해결에 얼마나 많은 시간이 소요되는지라면, 공간 복잡도는 얼마나 많은 메모리가 필요한지에 대한 복잡도다. 최근 하드웨어들은 메모리 용량이 크기 때문에 공간 복잡도가 크게 의미는 없지만, 임베디드 시스템처럼 제한된 성능에서는 중요해진다.  
  
시간 지역성 : 최근에 참조된 주소의 내용은 곧 다음에 다시 참조된다.  
공간 지역성 : 기억장치 내 서로 인접해 저장되어 있는 데이터가 연속적으로 액세스될 가능성이 높아진다.  
  
캐시 히트율은 지역성에 영향을 미치는데 시간 지역성의 경우 최근 접근한 데이터를 재사용하면 캐시 히트율이 높아 `O(n)` 알고리즘이 실제로는 더 짧은 `O(n/캐시 하인 크기)`로 동작할 수 있게 영향을 끼치고, 공간 지역성의 경우에는 인접 데이터를 순차 접근해 캐시 미스율이 낮아지면 알고리즘이 메모리에 접근하는 패널티가 줄어드는데 영향을 준다.  
  
시간 지역성이 좋은 경우는 반복문 내 변수처럼 최근에 접근했던 데이터에 바로 다시 접근하는 경우가 해당하고, 공간 지역성이 좋은 경우는 배열처럼 연속된 공간이 할당된 데이터를 순차적으로 읽을 때가 해당된다.  
  
#### 예시
```java
for (int i = 0; i < 1001; ++i) {
  for (int j = 0; j < 1001; ++j) {
    matrix[i][j] = 1;
  }
}

for (int i = 0; i < 1001; ++i) {
  for (int j = 0; j < 1001; ++j) {
    matrix[j][i] = 1;
  }
}
```
첫 번째 반복문처럼 같은 블록을 연속적으로 읽으면 공간 지역성이 좋지만, 두 번째 반복문처럼 여러 블록을 왔다갔다 하는 경우에는 공간 지역성이 좋지 않다. 시간 복잡도는 같은 코드지만 실제 수행 시간에 차이가 생기는 이유다.  
  
```java
// 기존: O(n)
class XYZ {
  int x;
  int y;
  int z;
}
XYZ[] arr = new XYZ[1000];

int[] x = new int[1000];
int[] y = new int[1000];
int[] z = new int[1000];
```
XYZ 배열보다는 연속된 공간을 사용할 수 있게 같은 타입끼리 배열을 사용해서 묶는 방식으로 데이터 구조를 재구성하면 공가 지역성 개선으로 캐시 히트율을 높일 수 있다.  
  
### 캐시 일관성을 유지하기 위한 방법
캐시 일관성은 공유 메모리 시스템에서 여로 프로세서가 각자의 로컬 캐시를 사용할 때, 동일한 데이터에 대해 일관된 값을 유지해야 되는 것으로, 프로세서 A가 변수 X를 수정하면, 프로세서 B가 변수 X를 읽으면 수정된 값을 가져와야 하고, 만약 일관성이 없다면 B는 수정 전 데이터를 읽을 수도 있다.  
  
이를 해결하기 위한 방식으로는 컴파일 시 문제를 검출하는 소프트웨어적 해결방식과 런타임 시 문제를 검출하는 하드웨어적 해결방식이 존재한다.  
  
#### 소프트웨어적 해결방식
운영체제와 컴파일러를 사용하는 해결방식으로, 안전하게 공유 변수를 사용할 수 있도록 주기를 설정하거나, 아예 공유 데이터 변수를 캐시에 저장하지 않도록 설정하는 방법 등이 존재한다.  
```java
public class CacheCoherenceExample {
    private volatile int sharedCounter = 0;

    // 값 증가
    public void increment() {
        sharedCounter++;
    }

    // 값 읽기
    public int getCounter() {
        return sharedCounter;
    }

    public static void main(String[] args) {
        CacheCoherenceExample example = new CacheCoherenceExample();

        // 쓰레드 생성 및 실행
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                example.increment();
            }
        });

        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                example.increment();
            }
        });

        t1.start();
        t2.start();

        try {
            t1.join();
            t2.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        // 최종 결과 출력
        System.out.println("Final Counter Value: " + example.getCounter());
    }
}
```
자바의 경우에는 위와 같이 `volatile` 키워드를 사용해 변수를 메인 메모리에 직접 저장하고 읽도록 강제할 수 있다.  
  
#### 하드웨어적 해결방식
**스누피 프로토콜 방식**  
공유 버스를 통해 모든 캐시가 트랜잭션을 감시하며 일관성을 유지한다. 캐시 컨트롤러가 버스에서 발생하는 모드 I/O 요청을 감시해 캐시 라인의 상태를 구분하고, 쓰기 작업 시 다른 캐시의 복사본을 무효화한다.  
  
예를 들어 프로세서 A가 주소 X를 수정하면 버스에 신호를 보내 상태를 바꾸면, 다른 프로세서가 주소 X를 읽으려하면 프로세서 A가 최신 데이터를 제공해준다.  
  
**디렉토리 프로토콜**  
중앙 디렉토리가 메모리 블록의 상태와 소유자를 추적해 일관성을 유지한다. 각 메모리 블록은 `Uncached`, `Shared`, `Exclusive` 상태를 가지고, 스누피와 다르게 브로드캐스트 방식이 아닌 관련된 노드만 통신해서 트래픽이 최소화된다.  
  
예를 들어, 프로세서 A가 주소 X를 수정하려면 디렉토리에 `Exclusive` 권한을 요청하고, 디렉토리는 주소 X를 공유 중인 다른 노드들에 무효화 신호를 보낸다.  
  
스누피는 버스 기반 시스템처럼 소규모에서 실시간으로 일관성을 관리하고, 디렉토리는 분산 환경에서 효율적으로 데이터를 관리해준다.  
  
### 캐시 일관성과 오라클 데이터베이스
위에서 살펴봤듯이 일관성을 유지하기 위해 브로드캐스트, 디렉토리, 동기화 등 다양한 방식을 사용하는데, 오라클에서도 공유 메모리 영역인 SGA에 존재하는 버퍼 캐시의 일관성을 래치를 통해 관리하고 있다.  
  
메모리 내 데이터 블록의 일관성은 다음과 같은 순서로 관리된다.  
  
1. 각 데이터 블록의 주소를 해시 함수로 계산한다.
2. 계산한 값으로 특정 해시 버킷에 매핑한다.
3. 동일 버킷에 속한 블록들은 연결 리스트(체인)로 관리된다.
4. 이 체인에 접근할 때 래치로 보호한다.
5. 프로세스들은 체인에 대한 래치를 획득해야 접근할 수 있다.
6. 한 번에 하나의 프로세스만 체인에 접근할 수 있다.
  
반면에 오라클에는 프로세스별로 독립적인 PGA라는 공간도 존재하는데, 독립적이기에 하나의 프로세스만 사용하는 공간이라 이러한 래치 획득 과정, 즉 캐시 일관성 유지 과정이 없기 때문에 빠른 속도로 처리할 수 있다.  
  
### 부품 간 전력 소모 순위
1. GPU (그래픽 카드) : 200W ~ 1000W
2. CPU : 고급 CPU는 작업 부하가 높을 때 130~150W 까지도 소모한다.
3. 메인보드 : 25~100W를 소모한다.
4. HDD : 0.7W ~ 9W, SSD보다 약간 더 높은 전력을 소모한다.
5. SSD : 0.6W ~ 3W를 소모한다.
6. RAM : 2W ~ 5.5W를 소모한다.
  
### 데이터 센터의 전력 소모 문제
데이터 센터는 전 세계 전기 소비량의 약 1~2%를 차지하고, 대부분이 화석 연료 기반 에너지로 수급하기 때문에 탄소 배출량 증가와 기후 변화 문제에도 영향을 끼친다.  
  
데이터 센터에서는 초고성능 컴퓨팅 및 서버를 24시간 가동시켜야 하기 때문에 피할 수 없는 많은 전력 소모가 발생하고, 해당 부분이 데이터 센터의 전력 소모량 40%를 차지한다.  
  
이런 초고성능 컴퓨팅 및 서버를 가동시키면 발생하는 열도 엄청나기 때문에, 이를 위한 냉각 시스템에 사용하는 전력오 40% 정도를 차지한다. 그외에 네트워크 및 스토리지 장비와 전력 관리 등이 20%를 차지한다.  
  
## 5주차
### 패킷과 패킷 공격
패킷은 큰 데이터를 여러 개의 작은 조각으로 나눈 데이터다.  
  
**헤더**  
패킷의 앞부분에 해당하며, 발신지와 목적지 정보, 데이터의 순서 등을 포함  
  
**페이로드**  
실제 데이터가 들어있는 부분  
  
여러 조각의 패킷은 개별적으로 목적지로 보내지고, 목적지에서 모여서 원래의 데이터로 조립된다.  
  
#### 패킷의 장점
1. 패킷은 독립적으로 전송되어 전체가 아닌 문제가 생긴 패킷만 재전송하면 된다.
2. 네트워크 노드 간 최적의 경로를 찾아 이동해서 회선 교환 방식보다 빠르다.
3. 작은 단위의 패킷을 여러 경로로 동시에 전송이 가능해 대역폭을 효율적으로 사용한다.  
    (대용량 데이터를 보내면 그동안 다른 데이터들은 대기해야 하는 단점이 없다.)
4. UDP와 같은 프로토콜을 사용해 연결 설정 없이 빠르게 데이터 전송이 가능하다.  
   (실시간성이 중요한 스트리밍과 게임 서비스에 적합하다.)
  
#### 패킷의 단점
1. 여러 경로를 통해 전송되기에 도착 시간에 차이가 있을 수 있다.
2. 패킷 손실이 발생하면 재전송이 필요해 지연이 발생한다.
3. 데이터의 순서와 도착 여부를 보장하지 않는다.
  
#### 패킷 공격
**DDos**  
대량의 패킷을 보내 과부하를 유발하는 공격으로, TCP 요청을 대량으로 보내 서버가 응답을 계속해서 기다리게해서 자원을 소모시키는 `SYN Flood`와 UDP 패킷을 무작위 포트로 보내 트래픽 처리 과부하를 유발하는 `UDP Flood` 공격이 있다.  
  
**패킷 스니핑**  
네트워크에서 전송되는 패킷을 가로채 정보를 훔치는 공격  
  
**패킷 크래프팅**  
특정 필드를 조작한 패킷을 생성해 보안을 우회하거나 취약점을 악용하는 공격  
  
### 오디오 샘플링
샘플링은 전체에서 대표할 수 있는 데이터들만 얻는 과정이다. 예를 들면, 선거 기간에 모든 사람을 대상으로 여론조사를 할 수는 없으니, 특정 지역과 연령대에서 일부를 대상으로 여론조사를 진행해 대략적인 분석을 진행하는 것과 같다.  
  
**오디오 샘플링**  
연속적인 아날로그 신호를 일정 시간 간격으로 나누어 각 지점의 소리 크기를 숫자로 기록하는 작업  
  
**샘플링 레이트**  
1초 동안 소리를 몇 번 측정할지를 나타내는 값으로 헤르츠(Hz)라는 단위를 사용한다.  
   
헤르츠가 높다면 그만큼 많은 소리를 측정했다는 것이니 품질이 좋고, 용량을 클것이고  
헤르츠가 낮다면 품질은 떨어지겠지만, 용량은 작아진다.  
  
**비트 깊이**  
샘플링한 각 샘플을 몇 비트로 표현할지를 나타내는 정도로, 소리 크기의 세부 정보를 얼마나 정밀하게 기록할지를 결정한다.  
  
**디지털 &rarr; 아날로그(DAC)**  
디지털 데이터는 사람이 들을 수 없는 데이터이기에 이를 다시 아날로그로 변환해야 한다.  
  
1. DAC가 디지털 데이터를 입력 받는다.
2. 각 디지털 값에 대응하는 전압 또는 전류를 생성한다.
3. 생성된 신호를 필터를 통해 부드럽게 처리해 연속적인 아날로그 신호로 출력한다.
  
이때 입력되는 디지털 데이터의 비트수(비트 깊이)가 많을 수록 더 세밀한 아날로그 신호를 생성할 수 있고, 헤르츠가 높을수록 더 자주 데이터를 변환해 더 자연스러운 소리를 만든다.