---
title: "Deep Dive"
date: 2025-03-27 20:40:00 +/-TTTT
categories: [Book, 한 권으로 읽는 컴퓨터 구조와 프로그래밍]
tags: [CS]
math: true
toc: true
# pin: true
---
## 3주차
### 프로그램이 실행되는 과정
책을 보다 데이터 경로와 제어 신호 부분에서 큰 이미지 자료가 딱 나오자마자 눈과 뇌가 받아들이질 못해서 직접 찾아봤다...  
  
#### 초기화
1. 프로그램 코드와 초기 데이터가 메모리에 저장된다.
2. 프로그램 카운터가 실행할 첫 번째 메모리 주소를 가리킨다.
3. 주소 버스를 통해 프로그램 카운터가 가리키는 주소를 메모리에 전달한다.
4. 데이터 버스를 통해 해당 주소에서 명령어를 가져와 CPU로 전달한다.
5. 명령어 레지스터에 가져온 명령어를 저장한다.
  
#### 명령어 사이클 : FETCH
1. 프로그램 카운터가 현재 실행할 명령어의 메모리 주소를 카리킨다.
2. 주소 버스 &rarr; 메모리 &rarr; 데이터 버스 &rarr; CPU &rarr; 명령어 레지스터
3. 프로그램 카운터가 다음 명령어를 가리키게 증가한다.
   
#### 명령어 사이클 : DECODE
1. 명령어 레지스터에 저장된 명령어를 디코딩해 어떤 작업을 수행할지 결정한다.
2. 피보나치의 경우 이전과 현재 값을 더해 다음 값을 계산한다 같은 작업 내용을 얻는다.
  
#### 데이터 읽기 및 연산 준비
1. 간접 주소 레지스터에서 계산에 필요한 데이터를 저장한 메모리 주소를 간접적으로 참조한다.
2. 주소 버스를 통해 간접 주소 레지스터가 가리키는 메모리 주소에 데이터를 요청한다.
3. 데이터 버스를 통해 메모리에서 데이터를 읽고 누산기에 올린다.
  
#### 연산 수행
1. ALU가 연산을 수행한다.
2. 연산 결과를 누산기에 저장한다.
3. 연산 결과에 따라 조건 코드 레지스터에 플래그를 설정한다.  
  
플래그는 오버플로 발생 여부 같은 것을 의미한다.
  
#### 결과 저장
1. 계산된 값을 데이터 버스를 통해 다시 메모리에 저장한다.
2. 현재 계산된 값을 다음 피보나치 수 계산에 다시 사용할 수 있도록 메모리나 레지스터에 저장한다.
  
#### 반복 및 종료
1. 프로그램 카운터가 다음 명령어로 이동하여 반복적으로 피보나치 값을 계산한다.
2. 종료 조건이 충족될 때까지 반복하고 종료한다.

#### 요약
1. 프로그램 카운터가 명령어를 가져온다
2. 명령어 레지스터에서 이를 해석하고, 필요한 데이터를 메모리에서 읽는다.
3. ALU가 연산을 수행하고 결과를 누산기에 저장한다.
4. 결과는 메모리에 기록되고, 조건 코드 레지스터가 상태를 업데이트한다.
5. 위 과정을 종료 조건까지 반복한다.
  
### 비트 플래그
정수의 각 비트를 상태를 나타내는 플래그로 사용하는 기법으로, 여러 상태를 하나의 변수로 관리할 수 있다.  
  
#### 사용자 권한 관리
사용자 권한이 다음과 같이 있을 때때
- 0001(1) : 읽기
- 0010(2) : 쓰기
- 0100(4) : 실행
- 1000(8) : 관리
  
권한 설정
```python
permissions = 0

permissions |= 1
permissions |= 2

print(bin(permissions))  # 출력: 0b11 (읽기 + 쓰기)
``` 
  
권한 확인
```python
if permissions & 2:  
    print("쓰기 권한 있음")
else:
    print("쓰기 권한 없음")
```
  
권한 제거 (and not)
```python
permissions &= ~2  

print(bin(permissions))  # 출력: 0b1 (읽기)
```
  
여러 권한 확인
```python
permissions = 1 | 2 | 4  

print(bin(permissions))  # 출력: 0b111 (읽기 + 쓰기 + 실행)
```
  
플래그 설정 = 왼쪽 시프트 연산
```python
# 읽기 권한 플래그 설정 (1번째 비트)
READ_PERMISSION = 1 << 0  # 1

# 쓰기 권한 플래그 설정 (2번째 비트)
WRITE_PERMISSION = 1 << 1  # 2

# 실행 권한 플래그 설정 (3번째 비트)
EXECUTE_PERMISSION = 1 << 2  # 4
```
  
플래그 확인 = 오른쪽 시프트 연산
```python
permissions = READ_PERMISSION | WRITE_PERMISSION  # 3 (0b11)

if (permissions >> 1) & 1:
    print("쓰기 권한 있음")
else:
    print("쓰기 권한 없음")

```
  
플래그 해제
```python
permissions &= ~(1 << 1)  # 1 (0b1)

print(bin(permissions))  # 0b1 (읽기 권한만 남음)
```
  
[관련 SQL 문제](https://school.programmers.co.kr/learn/courses/30/lessons/301647)

### GPU와 비트코인
비트 코인을 채굴할 때는 블록체인 네트워크에서 해시 함수를 반복적으로 계산해 블록을 유효화 하는 작업이 필요하고, 해당 과정에서 많은 수의 단순한 연산이 필요하다.  
  
GPU는 단순한 ALU 수백 수천 개를 내장하고, 병렬 처리에 특화되어 있기 때문에 이러한 부분에서 CPU보다 훨씬 더 많은 연산을 동시에 처리할 수 있어서 채굴에 사용되었다.
  
## 4주차
### 스택의 단점
호출 시 스위칭 문제 등
### 시간/공간 복잡도와 캐시 히트
### 스와핑과 가상 메모리
### 캐시 일관성을 유지하기 위한 방법