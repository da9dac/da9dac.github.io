---
title: "Deep Dive"
date: 2025-03-27 20:40:00 +/-TTTT
categories: [Book, 한 권으로 읽는 컴퓨터 구조와 프로그래밍]
tags: [CS]
math: true
toc: true
# pin: true
---
## 3주차
### 프로그램이 실행되는 과정
책을 보다 데이터 경로와 제어 신호 부분에서 큰 이미지 자료가 딱 나오자마자 눈과 뇌가 받아들이질 못해서 직접 찾아봤다...  
  
#### 초기화
1. 프로그램 코드와 초기 데이터가 메모리에 저장된다.
2. 프로그램 카운터가 실행할 첫 번째 메모리 주소를 가리킨다.
3. 주소 버스를 통해 프로그램 카운터가 가리키는 주소를 메모리에 전달한다.
4. 데이터 버스를 통해 해당 주소에서 명령어를 가져와 CPU로 전달한다.
5. 명령어 레지스터에 가져온 명령어를 저장한다.
  
#### 명령어 사이클 : FETCH
1. 프로그램 카운터가 현재 실행할 명령어의 메모리 주소를 카리킨다.
2. 주소 버스 &rarr; 메모리 &rarr; 데이터 버스 &rarr; CPU &rarr; 명령어 레지스터
3. 프로그램 카운터가 다음 명령어를 가리키게 증가한다.
   
#### 명령어 사이클 : DECODE
1. 명령어 레지스터에 저장된 명령어를 디코딩해 어떤 작업을 수행할지 결정한다.
2. 피보나치의 경우 이전과 현재 값을 더해 다음 값을 계산한다 같은 작업 내용을 얻는다.
  
#### 데이터 읽기 및 연산 준비
1. 간접 주소 레지스터에서 계산에 필요한 데이터를 저장한 메모리 주소를 간접적으로 참조한다.
2. 주소 버스를 통해 간접 주소 레지스터가 가리키는 메모리 주소에 데이터를 요청한다.
3. 데이터 버스를 통해 메모리에서 데이터를 읽고 누산기에 올린다.
  
#### 연산 수행
1. ALU가 연산을 수행한다.
2. 연산 결과를 누산기에 저장한다.
3. 연산 결과에 따라 조건 코드 레지스터에 플래그를 설정한다.  
  
플래그는 오버플로 발생 여부 같은 것을 의미한다.
  
#### 결과 저장
1. 계산된 값을 데이터 버스를 통해 다시 메모리에 저장한다.
2. 현재 계산된 값을 다음 피보나치 수 계산에 다시 사용할 수 있도록 메모리나 레지스터에 저장한다.
  
#### 반복 및 종료
1. 프로그램 카운터가 다음 명령어로 이동하여 반복적으로 피보나치 값을 계산한다.
2. 종료 조건이 충족될 때까지 반복하고 종료한다.

#### 요약
1. 프로그램 카운터가 명령어를 가져온다
2. 명령어 레지스터에서 이를 해석하고, 필요한 데이터를 메모리에서 읽는다.
3. ALU가 연산을 수행하고 결과를 누산기에 저장한다.
4. 결과는 메모리에 기록되고, 조건 코드 레지스터가 상태를 업데이트한다.
5. 위 과정을 종료 조건까지 반복한다.
  
### 비트 플래그
정수의 각 비트를 상태를 나타내는 플래그로 사용하는 기법으로, 여러 상태를 하나의 변수로 관리할 수 있다.  
  
#### 사용자 권한 관리
- 0001 : 읽기
- 0010 : 쓰기
- 0100 : 실행
- 1000 : 관리

