---
title: "인덱스 튜닝 - 인덱스 스캔 효율화와 설계"
date: 2025-03-23 17:05:00 +/-TTTT
categories: [Book, 친절한 SQL 튜닝]
tags: [SQL, DB, Oracle]
math: true
toc: true
# pin: true
---
# 인덱스 스캔 효율화
IOT, 클러스터, 파티션은 테이블 랜덤 액세스를 최소화할 때 효과적이지만, 이를 적용하려면 성능 검증을 위해 많은 테스트를 진행해야 하므로 어렵기에, 시스템 개발 단계에서 물리적 설계가 중요하다.  
  
그래서 운영 환경에서 당장 시도해볼만한 것이 테이블 스캔과 인덱스 스캔의 효율화를 위한 튜닝이고, 인덱스 스캔 효율화는 다양한 튜닝 요소가 존재한다.  
  
## 인덱스 탐색
기존에 배운 인덱스 탐색 방식에 대해 까먹었을 수도 있으니 다시 한 번 확인해보자  
  
**수직적 탐색**  
스캔을 시작할 리프 블록을 찾는 탐색으로, 루트 블록이 가리키고 있는 리프 블록으로 가는 것이 아니라, 직전 리프 블록으로 가야한다. 이는 루트 블록은 자신보다 크거나 같은 값을 갖고 있기 때문에 직전 블록부터 탐색해야 원하는 모든 값을 찾을 수 있다.  
  
**수평적 탐색**  
스캔 시작 지점에서 리프 블록을 순차적으로 탐색하는 방식이다.  
  
## 인덱스 스캔 효율성
인덱스 선행 컬럼이 조건절에 없거나, `=` 조건이 없다면 인덱스 스캔 과정에 비효율이 발생한다.  

### 인덱스 스캔 효율성 측정  
SQL 트레이스 분석을 통해 인덱스를 스캔해서 얻은 결과의 수와 스캔 과정에서 읽은 블록의 수를 비교해 스캔한 수에 비해 얻은 결과가 적을 수록 비효율적이라는 것을 알 수 있다.  
  
## 액세스 조건과 필터 조건
**인덱스 액세스 조건**  
인덱스의 스캔 범위를 결정하는 조건절로, 수직적 탐색을 통해 스캔 시작점을 결정할 때 영향을 미치고, 수평적 탐색의 중단점을 결정할 때 영향을 미친다.  
  
**인덱스 필터 조건**  
테이블로 액세스 할지 결정하는 조건절이다. 예를 들면, C1, C2, C3, C4 컬럼의 인덱스가 있을 때, 조건절에 C1, C2, C4 순으로 존재한다면, 선행 컬럼인 C3를 건너 뛰고 C4를 사용했기 때문에 해당 조건절에 의해 어떤 테이블로 액세스 할지가 결정된다.  
  
즉, 인덱스 스캔으로 데이터를 찾은 후, 추가적으로 필터링해야 할 조건이 있을 때 사용되고, 인덱스가 적용되지 않기 때문에 테이블을 읽게 되는 것이다.  
  
**테이블 필터 조건**  
인덱스 이용, 테이블 전체 스캔 여부와 상관 없이 테이블 액세스 단계에서 처리되는 조건절이다. 쿼리 수행 다음 단계로 전달하거나 최종 결과집합에 포함할지를 결정한다.  
  
## 비교 연산자 종류와 컬럼 순서에 따른 군집성
인덱스는 같은 값을 갖는 레코드끼리 군집해 있기 때문에, 같은 값을 찾을 때, `=` 연산자를 사용하면 누락 없이 조건절을 만족하는 레코드끼리 모여 있다. 반대로, 조건을 누락하거나 `=` 연산자가 아닌 다른 연산자로 조회하면 레코드가 흩어지게 된다.  
  
아래와 같은 경우에는 군집성을 사용해 효율적으로 인덱스 스캔이 가능하다.  
- 인덱스 구성 컬럼을 모두 `=` 조건으로 비교하는 경우  
- 선행 컬럼을 모두 `=` 조건으로 비교하고, 마지막 컬럼만 범위검색 조건인 경우  
  
군집성을 활용하지 못하는 경우는 다음과 같다.  
- 중간 컬럼이 범위검색 조건인 경우, 후행 컬럼까지 만족하는 레코드는 흩어진다.  
- 즉, 선행 컬럼이 모두 `=` 조건일 때, 이후에 처음 나타나는 범위검색 조건이 인덱스 스캔 범위다.   
- 범위검색 조건 이후에 나타나는 조건은 어떤 조건이든 상관 없이 흩어진다.   
  
**액세스 조건이 될 수 없는 케이스**  
- 좌변 컬럼을 가공한 조건절
- 왼쪽 `%` 또는 양쪽 `%` 기호를 사용한 조건절
- 같은 컬럼에 대한 조건절이 두 개 이상일 때, 액세스 조건으로 선택되지 못한 조건절  
- OR Expansion 또는 INLIST ITERATOR로 선택되지 못한 OR 또는 IN 조건절  
  
## 인덱스 선행 컬럼이 등치(=) 조건이 아닐 때 생기는 비효율
인덱스 스캔 효율성은 인덱스 컬럼을 조건절에 모두 등치 조건으로 사용할 때 좋은데, 이는 리프 블록을 스캔하면서 읽은 레코드를 하나도 버리지 않고 모두 테이블 액세스로 이어지기 때문에 비효율이 없어서다.  
  
인덱스 컬럼 중 일부가 조건절에 없거나 등치 조건이 아니라도 해당 조건들이 뒤쪽 컬럼인 경우에는 비효율이 없지만, 인덱스 선행 컬럼이 조건절에 없거나, 범위검색 조건이면 인덱스 스캔 단계에서 비효율이 발생한다.  
  
## BETWEEN &rarr; IN-List
범위검색으로 발생하는 비효율을 줄이기 위해 범위검색 컬럼이 맨 뒤로 가도록 인덱스 구성을 변경하는 방법이 있지만, 실제 운영 시스템에서 구성을 바꾸는 것은 쉽지 않기 때문에, IN-List를 사용하도록 바꿔주면 효율을 향상시킬 수 있다.  
  
IN-List를 사용하면 IN 절의 개수만큼 수직적 탐색을 수행 후, 수평적 탐색을 진행하기 때문에, 기존 BETWEEN 범위검색처럼 한 번의 수직적 탐색 후 스캔 중단점까지 모든 인덱스에 수평적 탐색을 수행할 필요가 없다.  
  
즉, 인덱스 탐색이 IN-List의 개수만큼 수행된다는 것인데, 범위검색에 사용된 컬럼이 등치 조건으로 리스트의 개수만큼 인덱스 탐색을 수행하게 되는 것이다.  
  
IN-List의 개수가 늘어날 수 있거나 많다면, NL 방식의 조인문이나 서브쿼리로 구현하면 되고, 방식은 범위검색 조건절은 그대로 두고 해당 컬럼을 조인 조건으로 사용해주면 끝이다.  
  
### BETWEEN 조건을 IN-List로 전환할 때 주의 사항
IN-List 개수가 많다는 것은 수직적 탐색 횟수가 그만큼 늘어난다는 것이기 때문에 리스트 개수가 너무 많은 경우에는 오히려 BETWEEN으로 인한 리프 블록 탐색 수보다 브랜치 블록을 반복 탐색하는 비효율이 클 수도 있고, 이는 루트에서 브랜치 블록까지 Depth가 깊을 때 특히 더 비효율적이다.  
  
리스트 개수가 적어도 스캔 과정에서 선택되는 레코드들이 서로 멀리 떨어져 있을 때만 유용하다. 가까이 붙어 있다면 BETWEEN 검색과 큰 차이가 없고, 오히려 더 비효울적일 수 있기 때문이다.  
  
## Index Skip Scan 활용
BETWEEN 조건을 유지하면서 IN-List를 사용한 것과 같은 효과를 낼 수도 있다. 조건절을 유지하고 Index Skip Scan 힌트를 추가해주면 되고, 이 방법도 IN-List와 마찬가지로 레코드의 군집성이 낮을 때 효율적이다.  
  
## IN 조건은 '='인가  
IN 조건이 등치 조건이 되려면 IN-List Iterator 방식으로 풀려야만 하고, 그렇지 않다면 필터 조건이 된다. IN 조건을 액세스 조건으로 만들기 위해 IN-List Iterator 방식을 사용할 수는 있어도, 해당 조건에 사용되는 컬럼이 액세스 조건으로서 의미가 크지 않다면 액세스 조건보다 필터 방식으로 처리되는게 나을 수도 있다.  
  
즉, IN 조건은 등치 조건이 아니다!!  
  
### NUM_INDEX_KEYS
IN=List를 액세스 조건이나 필터 조건으로 유도하려면, num_index_keys 힌트를 사용해 인덱스의 특정 순서 컬럼까지만 액세스 조건으로 사용하게 할 수 있다.  
  
## BETWEEN과 LIKE 스캔 범위 비교
두 범위검색 조건 모두 비효율 원리가 똑같이 적용되지만, BETWEEN이 조금이라도 더 스캔량이 적을 수 있기 때문에, 가급적이면 LIKE 보단 BETWEEN을 선호하는 것이 좋다. BETWEEN은 시작과 끝이 명확하지만, LIKE는 명확하지 않기 때문에 BETWEEN에 비해 앞뒤로 스캔량이 더 많다.  
  
## 범위검색 조건을 남용할 때 생기는 비효율
개발할 때 간편하게 작성하려고 범위검색 시 LIKE를 남용하는 경우가 많은데, 해당 컬럼이 인덱스 구성 컬럼일 때는 조심해야 한다. 선행 혹은 중간 컬럼에 대해 LIKE 조건을 사용 시, 해당 조건은 액세스 조건이 아닌 필터 조건으로 바뀌게 된다.  
  
그렇다고 무조건 BETWEEN을 사용하라는 것은 아니다. 코딩을 쉽게 할려고 인덱스 컬럼에 범위검색을 과도하게 사용해서, 하나의 쿼리로 한 번에 처리하려고 하기 보다는 귀찮더라도 상황에 맞는 효율적인 쿼리를 각각 작성해주는 것이 좋다. 특히 대량 테이블에 대해 범위 검색 시에는 영향이 더 크기 때문에 주의해야 한다.  
  
## 다양한 옵션 조건 처리 방식의 장단점 비교
### OR 조건 활용
OR 조건 사용 시 흔히 발생하는 문제점은 옵션 조건 컬럼을 선두에 두고 인덱스를 구성해도 인덱스를 사용할 수 없는 것으로, 인덱스 선두 컬럼에 대한 옵션 조건 OR을 사용하면 안되는 것이다.  
  
OR 조건은 인덱스 액세스 조건과 필터 조건으로 사용할 수 없고, 테이블 필터 조건으로만 사용 가능하다. 단, 인덱스 구성 컬럼 중 하나 이상이 Not Null 컬럼이면 18c 부터 인덱스 필터 조건으로 사용 가능하다.  
  
결국 OR 조건은 인덱스를 효율적으로 사용할 수 없는 특성이 있기 때문에, 가급적이면 해당 조건을 사용한 옵션 처리는 사용하지 않는 것이 좋다. 해당 방식의 장점은 다른 옵션들과 다르게 NULL 허용 컬럼이더라도 결과집합을 보장한다는 것뿐이다. (다른 조건식에서의 NULL과의 비교는 FALSE나 UNKNOWN을 반환하거나, 결과에서 제외되지만, OR은 한 쪽 조건이 NULL이더라도 다른 쪽 조건이 참이라면 결과에 포함된다.)  
  
### LIKE/BETWEEN 조건 활용
변별력이 좋은 필수 조건이 있는 상황에서 두 옵션들을 사용하는 것은 나쁘지 않다. 필수 조건 컬럼을 인덱스 선두로 두고 액세스 조건으로 사용하면, 범위검색 조건이 인덱스 필터 조건이어도 충분한 성능이 나온다. 필수 조건이 등치 조건으로 사용된다면, 뒤에 오는 범위검색도 인덱스 액세스 조건으로 사용될 수도 있어서 더욱 좋다.  
  
하지만, 필수 조건의 변별력이 좋지 않은 경우에는 인덱스 스캔보다 Table Full Scan이 유리할 수도 있다.  
  
참고로, BETWEEN 조건을 사용할 때는 두 가지 경우에 해당하지 않는지 확인하고 사용해야 한다.  
1. 인덱스 선두 컬럼인가?  
2. NULL을 허용하는 컬럼인가?  
  
LIKE 조건을 사용할 때는 위의 두 가지 경우에 더해 아래의 경우도 확인해야 한다.  
1. 숫자형 컬럼인가?
2. 가변 길이 컬럼인가?  
  
인덱스 선두 컬럼에 대해 범위검색을 사용하면 인덱스 스캔 과정에 비효율이 존재하지만, 변별력이 좋은 컬럼이라면 비교적 빠르게 조회가 가능하다. 하지만 LIKE 조건에 입력이 주어지지 않았다면, 인덱스를 전체 스캔하면서 이후에 오는 컬럼을 필터링하는 비효율의 비효율이 발생한다.  
  
NULL 허용 컬럼에 대해 범위검색을 사용하면 해당 조건들은 NULL 값을 결과집합에서 제외하기 때문에 NULL 값인 경우도 조회하고 싶다면 범위검색을 사용해서는 안된다.  
  
또한, LIKE는 숫자형 컬럼과 비교 시 문자열 비교로 처리하여 형변환이 발생하기 때문에 해당 컬럼을 인덱스 액세스 조건으로 사용할 수 없고, 필터 조건으로 사용하게 된다.  
  
마지막으로, LIKE는 컬럼 값 길이가 고정적일 때만 사용해야 한다. 가변 길이 컬럼이라면 예상치 못한 데이터까지 스캔하기 때문에 조심해야 하고, 가변적일 때는 길이가 같은 레코드만 조회하도록 조건을 추가하거나, `%` 자체를 사용하지 않는 방법도 있다.  
  
### UNION ALL 활용
```sql
where :값 is null
union all
where :값 is not null
```
위와 같이 변수의 값을 입력했는지에 따라 위 아래 중 하나의 쿼리만 실행되도록 분기 처리를 할 수도 있다. 두 분기에서 인덱스를 가장 최적으로 사용할 수 있게 만들 수 있는 방법이다.  
  
### NVL/DECODE 함수 활용
NVL : NULL 값을 지정된 기본값으로 대체하거나, NULL이 아닌 경우 원래 값 반환  
DECODE : IF-THEN-ELSE 로직과 같은 원리로 여러 조건 비교후 해당 결과 반환  
  
UNION ALL과 마찬가지로 NULL인 경우와 아닌 경우에 대한 분기처리가 가능한데 NVL과 DECODE 중 어떤 방식을 사용하든 실행 계획은 똑같다. 두 함수를 사용해서 컬럼을 가공해도 인덱스를 사용할 수 있는 이유는 OR Expansion 쿼리 변환이 일어나서 가능하다. 즉, 자동으로 UNION ALL로 변환이 된 것이다.  
  
이 방식은 옵션 조건 컬럼을 인덱스 액세스 조건으로 사용할 수 있고, UNION ALL과 같은 성능을 더 단순한 쿼리로 작성할 수 있다는 것이다.