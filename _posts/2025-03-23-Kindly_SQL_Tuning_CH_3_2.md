---
title: "인덱스 튜닝 - 인덱스 스캔 효율화와 설계"
date: 2025-03-23 17:05:00 +/-TTTT
categories: [Book, 친절한 SQL 튜닝]
tags: [SQL, DB, Oracle]
math: true
toc: true
# pin: true
---
# 인덱스 스캔 효율화
IOT, 클러스터, 파티션은 테이블 랜덤 액세스를 최소화할 때 효과적이지만, 이를 적용하려면 성능 검증을 위해 많은 테스트를 진행해야 하므로 어렵기에, 시스템 개발 단계에서 물리적 설계가 중요하다.  
  
그래서 운영 환경에서 당장 시도해볼만한 것이 테이블 스캔과 인덱스 스캔의 효율화를 위한 튜닝이고, 인덱스 스캔 효율화는 다양한 튜닝 요소가 존재한다.  
  
## 인덱스 탐색
기존에 배운 인덱스 탐색 방식에 대해 까먹었을 수도 있으니 다시 한 번 확인해보자  
  
**수직적 탐색**  
스캔을 시작할 리프 블록을 찾는 탐색으로, 루트 블록이 가리키고 있는 리프 블록으로 가는 것이 아니라, 직전 리프 블록으로 가야한다. 이는 루트 블록은 자신보다 크거나 같은 값을 갖고 있기 때문에 직전 블록부터 탐색해야 원하는 모든 값을 찾을 수 있다.  
  
**수평적 탐색**  
스캔 시작 지점에서 리프 블록을 순차적으로 탐색하는 방식이다.  
  
## 인덱스 스캔 효율성
인덱스 선행 컬럼이 조건절에 없거나, `=` 조건이 없다면 인덱스 스캔 과정에 비효율이 발생한다.  

### 인덱스 스캔 효율성 측정  
SQL 트레이스 분석을 통해 인덱스를 스캔해서 얻은 결과의 수와 스캔 과정에서 읽은 블록의 수를 비교해 스캔한 수에 비해 얻은 결과가 적을 수록 비효율적이라는 것을 알 수 있다.  
  
## 액세스 조건과 필터 조건
**인덱스 액세스 조건**  
인덱스의 스캔 범위를 결정하는 조건절로, 수직적 탐색을 통해 스캔 시작점을 결정할 때 영향을 미치고, 수평적 탐색의 중단점을 결정할 때 영향을 미친다.  
  
**인덱스 필터 조건**  
테이블로 액세스 할지 결정하는 조건절이다. 예를 들면, C1, C2, C3, C4 컬럼의 인덱스가 있을 때, 조건절에 C1, C2, C4 순으로 존재한다면, 선행 컬럼인 C3를 건너 뛰고 C4를 사용했기 때문에 해당 조건절에 의해 어떤 테이블로 액세스 할지가 결정된다.  
  
즉, 인덱스 스캔으로 데이터를 찾은 후, 추가적으로 필터링해야 할 조건이 있을 때 사용되고, 인덱스가 적용되지 않기 때문에 테이블을 읽게 되는 것이다.  
  
**테이블 필터 조건**  
인덱스 이용, 테이블 전체 스캔 여부와 상관 없이 테이블 액세스 단계에서 처리되는 조건절이다. 쿼리 수행 다음 단계로 전달하거나 최종 결과집합에 포함할지를 결정한다.  
  
## 비교 연산자 종류와 컬럼 순서에 따른 군집성
인덱스는 같은 값을 갖는 레코드끼리 군집해 있기 때문에, 같은 값을 찾을 때, `=` 연산자를 사용하면 누락 없이 조건절을 만족하는 레코드끼리 모여 있다. 반대로, 조건을 누락하거나 `=` 연산자가 아닌 다른 연산자로 조회하면 레코드가 흩어지게 된다.  
  
아래와 같은 경우에는 군집성을 사용해 효율적으로 인덱스 스캔이 가능하다.  
- 인덱스 구성 컬럼을 모두 `=` 조건으로 비교하는 경우  
- 선행 컬럼을 모두 `=` 조건으로 비교하고, 마지막 컬럼만 범위검색 조건인 경우  
  
군집성을 활용하지 못하는 경우는 다음과 같다.  
- 중간 컬럼이 범위검색 조건인 경우, 후행 컬럼까지 만족하는 레코드는 흩어진다.  
- 즉, 선행 컬럼이 모두 `=` 조건일 때, 이후에 처음 나타나는 범위검색 조건이 인덱스 스캔 범위다.   
- 범위검색 조건 이후에 나타나는 조건은 어떤 조건이든 상관 없이 흩어진다.   
  
**액세스 조건이 될 수 없는 케이스**  
- 좌변 컬럼을 가공한 조건절
- 왼쪽 `%` 또는 양쪽 `%` 기호를 사용한 조건절
- 같은 컬럼에 대한 조건절이 두 개 이상일 때, 액세스 조건으로 선택되지 못한 조건절  
- OR Expansion 또는 INLIST ITERATOR로 선택되지 못한 OR 또는 IN 조건절  
  
## 인덱스 선행 컬럼이 등치(=) 조건이 아닐 때 생기는 비효율
인덱스 스캔 효율성은 인덱스 컬럼을 조건절에 모두 등치 조건으로 사용할 때 좋은데, 이는 리프 블록을 스캔하면서 읽은 레코드를 하나도 버리지 않고 모두 테이블 액세스로 이어지기 때문에 비효율이 없어서다.  
  
인덱스 컬럼 중 일부가 조건절에 없거나 등치 조건이 아니라도 해당 조건들이 뒤쪽 컬럼인 경우에는 비효율이 없지만, 인덱스 선행 컬럼이 조건절에 없거나, 범위검색 조건이면 인덱스 스캔 단계에서 비효율이 발생한다.  
  
## BETWEEN &rarr; IN-List
범위검색으로 발생하는 비효율을 줄이기 위해 범위검색 컬럼이 맨 뒤로 가도록 인덱스 구성을 변경하는 방법이 있지만, 실제 운영 시스템에서 구성을 바꾸는 것은 쉽지 않기 때문에, IN-List를 사용하도록 바꿔주면 효율을 향상시킬 수 있다.  
  
IN-List를 사용하면 IN 절의 개수만큼 수직적 탐색을 수행 후, 수평적 탐색을 진행하기 때문에, 기존 BETWEEN 범위검색처럼 한 번의 수직적 탐색 후 스캔 중단점까지 모든 인덱스에 수평적 탐색을 수행할 필요가 없다.  
  
즉, 인덱스 탐색이 IN-List의 개수만큼 수행된다는 것인데, 범위검색에 사용된 컬럼이 등치 조건으로 리스트의 개수만큼 인덱스 탐색을 수행하게 되는 것이다.  
  
IN-List의 개수가 늘어날 수 있거나 많다면, NL 방식의 조인문이나 서브쿼리로 구현하면 되고, 방식은 범위검색 조건절은 그대로 두고 해당 컬럼을 조인 조건으로 사용해주면 끝이다.  
  
### BETWEEN 조건을 IN-List로 전환할 때 주의 사항
IN-List 개수가 많다는 것은 수직적 탐색 횟수가 그만큼 늘어난다는 것이기 때문에 리스트 개수가 너무 많은 경우에는 오히려 BETWEEN으로 인한 리프 블록 탐색 수보다 브랜치 블록을 반복 탐색하는 비효율이 클 수도 있고, 이는 루트에서 브랜치 블록까지 Depth가 깊을 때 특히 더 비효율적이다.  
  
리스트 개수가 적어도 스캔 과정에서 선택되는 레코드들이 서로 멀리 떨어져 있을 때만 유용하다. 가까이 붙어 있다면 BETWEEN 검색과 큰 차이가 없고, 오히려 더 비효울적일 수 있기 때문이다.  
  
## Index Skip Scan 활용
BETWEEN 조건을 유지하면서 IN-List를 사용한 것과 같은 효과를 낼 수도 있다. 조건절을 유지하고 Index Skip Scan 힌트를 추가해주면 되고, 이 방법도 IN-List와 마찬가지로 