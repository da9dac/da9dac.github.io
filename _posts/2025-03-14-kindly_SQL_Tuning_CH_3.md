---
title: "[친절한 SQL 튜닝] 인덱스 튜닝"
date: 2025-03-14 19:44:00 +/-TTTT
categories: [Book, 친절한 SQL 튜닝]
tags: [SQL, DB, Oracle]
math: true
toc: true
# pin: true
---
# 테이블 액세스 최소화
SQL 튜닝은 랜덤 I/O를 줄이는 것이라고 1장과 2장에서도 언급했지만,  
3장에 도착하면 랜덤 I/O가 뭐였더라는 생각이 들 수도 있다. ~~내가 그렇다는건 아니고...~~  
  
그런 사람들을 위해 다시 한 번 정리하고 넘어가자  
  
순차 I/O : 연속된 블록을 순차적으로 탐색해 디스크의 헤드 이동이 최소화 되어 빠름  
랜덤 I/O : 여러 위치에 흩어진 블록을 탐색해 디스크의 헤드 이동 시간이 길어져 느림  
  
![Image](https://github.com/user-attachments/assets/069bb4c7-566b-4af9-bbea-4abd2a814e11){: .align-right}{: width="80%" height="80%"}  
  
## 테이블 랜덤 액세스
인덱스는 대량의 데이터에서 소량의 데이터를 찾을 때 효율적이지  
대량의 데이터를 조회할 때는 테이블 풀 스캔보다도 효율적이지 않다.  
  
### 인덱스의 ROWID
SQL이 참조하는 컬럼을 인덱스가 모두 포함하는 경우가 아니면 인덱스 스캔 후 반드시 테이블에 액세스 하는데  
이런 경우 실행계획에서 TABLE ACCESS BY INDEX ROWID 라는 것을 볼 수 있다.  
  
즉, 인덱스 스캔의 이유는 검색 조건을 만족하는 소량의 데이터를 빠르게 찾고,  
거기서 테이블 레코드를 찾아가기 위한 ROWID를 얻기 위함이다.  
(커버링 인덱스를 제외한 경우에는 테이블 스캔이 발생한다 생각하면 된다)  
  
ROWID는 물리적 요소인 데이터파일 번호, 오브젝트 번호, 블록 번호로 구성되어 있어  
물리적 주소라고 볼 수도 있지만, 테이블 레코드를 찾아가기 위한 논리적 주소 정보를 담고 있지  
물리적으로는 연결되어 있지 않기에 논리적 주소에 가깝다.  

결국 ROWID는 프로그래밍의 포인터처럼 물리적으로 메모리의 데이터를 가리키고 있는 것이 아니기에  
포인터처럼 빠르지는 않고 테이블 레코드를 찾아가기 위한 위치 정보에 불과하다.  
  
### 메인 메모리 DB
데이터를 모두 메모리(버퍼 캐시)에 로드 후에 인덱스를 수행하는 DB로, 메모리에서 I/O를 수행하는데,  
해당 DB의 인덱스는 포인터처럼 메모리 상의 주소 정보를 갖는다.  
  
하지만, 오라클의 경우에는 테이블 블록이 버퍼 캐시에서 밀려나고 다시 새로운 공간에 캐싱되는 것을  
반복하기 때문에 인덱스에서 포인터로 직접 연결을 할 수 없다.  

즉, 인덱스는 포인트가 아니고, 이는 다른 말로 메모리 주소 정보가 아닌 디스크 주소 정보라는 것이다.  
  
### I/O 매커니즘 복습
인덱스의 경우 : 리프 블록 &rarr; DBA &rarr; 버퍼 캐시(버퍼 헤더 &rarr; 버퍼 블록) &rarr; 디스크  
테이블의 경우 : 익스텐트 맵 &rarr; DBA &rarr; 버퍼 캐시(버퍼 헤더 &rarr; 버퍼 블록) &rarr; 디스크  
  
기억해두자!
1. 디스크를 읽기 전에 버퍼 캐시에 등록한 후에 읽는다
2. 모든 데이터가 캐싱되어 있어도 매번 DBA 해싱과 래치 획득 과정을 거쳐야한다.
3. 동시 액세스가 심한 경우에는 캐시버퍼 체인 래치와 버퍼 Lock 경합도 발생한다.
  
즉, ROWID를 이용한 테이블 액세스는 가벼운 작업이 아니다.
  
## 인덱스 클러스터링 팩터(Clustering Factor:CF)
CF : 특정 컬럼을 기준으로 같은 값을 갖는 데이터가 밀집되어 있는 정도  
  
CF기 높은 컬럼에 생성한 인덱스는 검색 효율이 매우 좋다  
= 데이터가 물리적으로 근접해 있어 검색 속도가 빠르다  
= 인덱스 레코드 정렬 순서와 테이블 레코드 정렬 순서가 비슷하다  
  
CF가 높은 컬럼은 테이블 액세스량에 비해 블록 I/O가 적게 발생해서 효율적인데  
이는 오라클에선 ROWID로 테이블 액세스 시 어렵게 찾아간 테이블 블록에 대한 포인터를  
바로 해제하지 않고 유지하는 Buffer Pinning 방식을 사용하기 때문이다.  
CF가 높을수록 직전과 같은 태이블 블록을 가리킬 확률이 높기 때문에  
매번 래치 획득과 해시 체인 스캔을 할 필요 없이 생략하고 테이블 블록을 읽을 수 있다.  
  
## 인덱스 손익분기점
Index Range Scan이 Table Full Scan보다 느려지는 지점  
  
Table Full Scan은 전체에서 몇 건을 조회하든 성능상 차이가 거의 없지만,  
인덱스로 테이블에 액세스 할 때는 테이블 랜덤 액세스로 인해 조회하려는 데이터가 많을수록 느려진다.  
  
인덱스가 많은 데이터 조회 시 비효율적인 가장 큰 이유는 다음과 같다.  
- 랜덤 액세스 방식 사용
- Single Block I/O 방식 사용
  
이러한 이유들로 인덱스 손익분기점은 CF가 높고 낮은지에 따라 결정되는데,  
낮은 경우에는 5% 미만에서 결정되고, 높으면 90% 수준까지도 상승하지만,  
일반적으로는(10만~100만 정도의 테이블) 5% ~ 20%다.  
  
테이블의 크기가 커질수록 손익분기점은 낮아지는데 이는 BCHR과 연관이 있다.  
  
테이블 크기가 작을 때는 인덱스 컬럼 기준 값이 같은 블록에 있을 확률이 높기 때문에  
인덱스를 스캔하다보면 블록을 캐시에서 찾을 확률이 높다.  
  
하지만, 테이블 크기가 커지면 값들이 여러 블록에 흩어져 있을 확률이 높기 때문에  
인덱스를 스캔하다보면 초기에 읽어야하는 블록들이 많아질 수 밖에 없고,  
여러 건의 요청이 같이 버퍼 캐시를 사용하다보면 캐싱해둔 블록들이 자주 사라져서  
블록을 다시 읽어야 하는 경우가 많아져서 BCHR이 높지 않고, 당연히 손익분기점도 낮아진다.  
  
### 온라인 프로그램 튜닝과 배치 프로그램 튜닝
온라인 프로그램 : 주로 소량 데이터를 읽고 갱신하기에 인덱스의 효과적인 활용이 중요하다.  
(인덱스와 NL 조인이 효율적으로 자주 사용되는 이유)  
  
배치 프로그램 : 대량 데이터를 읽고 갱신해 전체범위 처리 기준으로 튜닝해야 한다.  
(Full Scan과 해시 조인이 효율적으로 자주 사용되는 이유) + (파티셔닝, 병렬 처리)  
  
## 인덱스 컬럼 추가
테이블 액세스를 최소화 하기 위해 가장 일반적으로 사용할 수 있는 튜닝 기법이다.  
  
인덱스의 기존 구성을 변경하는 작업은 다른 SQL들에 영향을 줄 수 있고,  
매번 필요한 인덱스를 추가하면 인덱스 관리 비용 증가와 DML 부하로 인한 트랜잭션 성능 저하가 생긴다.  
  
그래서 가장 무난하게 시도해볼 수 있는 방식이 기존 인덱스에 컬럼을 추가하는 것이다.  
특히, 테이블 액세스 단계에서 필터 조건에 의해 버려지는 레코드가 많을 때 효율적이다.  
  
## 인덱스만 읽고 처리
하지만, 필터 조건에 의해 버려지는 레코드가 거의 없어서 얻는 데이터가 그냥 많은 것이라면  
랜덤 액세스는 많이 발생해 성능은 느리지만 비효율이 있다고 볼 수는 없다.  
  
이렇게 절대 일량이 많아서 어쩔 수 없이 느린 경우에는 쿼리에 사용된 모든 컬럼을 인덱스로 갖는  
Covered Index를 통해 테이블 액세스 자체를 발생하지 않게 하는 방법을 고려해볼 수 있다.  
  
테이블 액세스가 사라지니 성능은 확실히 좋지만, 추카해야할 컬럼이 많다면 적용하기가 힘들다.  
  
### Include Index
SQL Server에 추가된 기능으로, 인덱스 키 외에 미리 지정한 컬럼을 리프 레벨에 함께 저장한다.  
  
기존 인덱스 방식은 인덱스에 사용된 컬럼 전체를 루트와 브랜치 블록에 저장하지만,  
해당 방식은 포함하는 컬럼은 리프 블록에만 저장한다.  
  
수직적 탐색에는 인덱스에 사용된 컬럼을, 수평적 탐색에는 포함된 컬럼을 필터 조건으로 사용할 수 있다.  
즉, 포함되는 컬럼은 테이블 랜덤 액세스를 줄이기 위한 용도로만 사용된다.  

두 인덱스 모두 같은 쿼리에 대한 랜덤 액세스 측면에서는 일량은 같지만,  
기존 인덱스 방식이 인덱스 스캔량은 더 적다.  
  
그리고 Include Index는 결국 랜덤 액세스를 줄이기 위한 용도로만 존재하기 때문에  
조회 시 기존 인덱스 방식처럼 정렬 연산을 생략할 수는 없다.  
  
## 인덱스 구조 테이블
인덱스를 이용한 테이블 액세스는 고비용 구조다!  
그러면 테이블을 인덱스 구조로 생성해서 랜덤 액세스를 없애자!  
= IOT(Oracle, Index-Organized Table), Clustered Index(MS-SQL)  
  
일반적인 인덱스는 테이블을 찾아가기 위한 ROWID를 갖고 있지만,  
IOT는 인덱스 리프 블록에 기존 테이블 블록이 갖고 있을 데이터를 모두 저장하고 있는다.  
(인덱스 리프 블록 == 데이터 블록)  
  
일반 테이블은 힙 구조 테이블로 데이터가 입력될 때 랜덤 방식을 사용
  
# 나중에 찾아볼 내용
1. Partition Pruning