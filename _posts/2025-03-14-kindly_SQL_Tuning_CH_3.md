---
title: "[친절한 SQL 튜닝] 인덱스 튜닝"
date: 2025-03-14 19:44:00 +/-TTTT
categories: [Book, 친절한 SQL 튜닝]
tags: [SQL, DB, Oracle]
math: true
toc: true
# pin: true
---
# 테이블 액세스 최소화
SQL 튜닝은 랜덤 I/O를 줄이는 것이라고 1장과 2장에서도 언급했지만,  
3장에 도착하면 랜덤 I/O가 뭐였더라는 생각이 들 수도 있다. ~~내가 그렇다는건 아니고...~~  
  
그런 사람들을 위해 다시 한 번 정리하고 넘어가자  
  
순차 I/O : 연속된 블록을 순차적으로 탐색해 디스크의 헤드 이동이 최소화 되어 빠름  
랜덤 I/O : 여러 위치에 흩어진 블록을 탐색해 디스크의 헤드 이동 시간이 길어져 느림  
  
## 테이블 랜덤 액세스
인덱스는 대량의 데이터에서 소량의 데이터를 찾을 때 효율적이지  
대량의 데이터를 조회할 때는 테이블 풀 스캔보다도 효율적이지 않다.  
  
### 인덱스의 ROWID
SQL이 참조하는 컬럼을 인덱스가 모두 포함하는 경우가 아니면 인덱스 스캔 후 반드시 테이블에 액세스 하는데  
이런 경우 실행계획에서 TABLE ACCESS BY INDEX ROWID 라는 것을 볼 수 있다.  
  
즉, 인덱스 스캔의 이유는 검색 조건을 만족하는 소량의 데이터를 빠르게 찾고,  
거기서 테이블 레코드를 찾아가기 위한 ROWID를 얻기 위함이다.  
(커버링 인덱스를 제외한 경우에는 테이블 스캔이 발생한다 생각하면 된다)  
  
ROWID는 물리적 요소인 데이터파일 번호, 오브젝트 번호, 블록 번호로 구성되어 있어  
물리적 주소라고 볼 수도 있지만, 테이블 레코드를 찾아가기 위한 논리적 주소 정보를 담고 있지  
물리적으로는 연결되어 있지 않기에 논리적 주소에 가깝다.  

결국 ROWID는 프로그래밍의 포인터처럼 물리적으로 메모리의 데이터를 가리키고 있는 것이 아니기에  
포인터처럼 빠르지는 않고 테이블 레코드를 찾아가기 위한 위치 정보에 불과하다.  
  
### 메인 메모리 DB
데이터를 모두 메모리(버퍼 캐시)에 로드 후에 인덱스를 수행하는 DB로, 메모리에서 I/O를 수행하는데,  
해당 DB의 인덱스는 포인터처럼 메모리 상의 주소 정보를 갖는다.  
  
하지만, 오라클의 경우에는 테이블 블록이 버퍼 캐시에서 밀려나고 다시 새로운 공간에 캐싱되는 것을  
반복하기 때문에 인덱스에서 포인터로 직접 연결을 할 수 없다.  

즉, 인덱스는 포인트가 아니고, 이는 다른 말로 메모리 주소 정보가 아닌 디스크 주소 정보라는 것이다.  
  
### I/O 매커니즘 복습
인덱스의 경우 : 리프 블록 &rarr; DBA &rarr; 버퍼 캐시(버퍼 헤더 &rarr; 버퍼 블록) &rarr; 디스크  
테이블의 경우 : 익스텐트 맵 &rarr; DBA &rarr; 버퍼 캐시(버퍼 헤더 &rarr; 버퍼 블록) &rarr; 디스크  
  
기억해두자!
1. 디스크를 읽기 전에 버퍼 캐시에 등록한 후에 읽는다
2. 모든 데이터가 캐싱되어 있어도 매번 DBA 해싱과 래치 획득 과정을 거쳐야한다.
3. 동시 액세스가 심한 경우에는 캐시버퍼 체인 래치와 버퍼 Lock 경합도 발생한다.
  
즉, ROWID를 이용한 테이블 액세스는 가벼운 작업이 아니다.
  
### ROWID는 우편주소

# 나중에 찾아볼 내용
1. Partition Pruning