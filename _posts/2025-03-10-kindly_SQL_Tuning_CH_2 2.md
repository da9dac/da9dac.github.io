---
title: "[친절한 SQL 튜닝] 인덱스 기본 2"
date: 2025-03-10 20:20:00 +/-TTTT
categories: [Book, 친절한 SQL 튜닝]
tags: [SQL, DB, Oracle]
math: true
toc: true
# pin: true
---
# 인덱스 기본 사용법
인덱스 탐색 과정은 수직적탐색과 수평적 탐색 두 단계로 이루어진다.  

## 인덱스를 Range Scan 할 수 없는 이유
인덱스 컬럼을 가공하면 인덱스를 정상적으로 사용할 수 없다는 말에서  
인덱스를 정상적으로 사용할 수 없다는 말은  
Index Range Scan을 할 수 없다는 말이다.  
  
가공 시에는 인덱스 스캔 시작점을 찾을 수 없기 때문에  
필요한 범위만 탐색할 수가 없기 때문이다.  

가공한 값, 치환한 값, 중간에 포함된 값 등은  
인덱스에 저장되어 있지 않기 때문에 범위 스캔이 불가능하다.  
(substr, nvl, like %s%, or, in)  

LIKE 검색 같은 경우 시작하는 값은 범위 스캔이 가능하지만  
포함된 값은 특정 구간에 모여있지 않기 때문에 범위 스캔이 불가능하다.  
  
OR 검색 같은 경우도 시작 지점이 한 군데가 아니라  
여러 곳에 존재하기 때문에 범위 스캔이 불가능하다.  
  
하지만, OR Expansion을 통해 OR 조건별로 조회 후에  
UNION을 통해 결과를 합치는 방식을 사용하면 범위 스캔을 할 수 있다.  
  
IN 조건절도 OR 조건절과 같은 방식이기 때문에 범위 스캔이 불가능하고,  
IN 조건절에 대해 옵티마이저는 IN-List Iterator 방식을 사용해  
IN-List 크기만큼 범위 스캔을 반복한다. (= OR Expansion)  
  
## 더 중요한 인덱스 사용 조건
인덱스를 만든다는 것은 인덱스에 사용되는 컬럼 순서대로  
정렬 기준이 만들어진다는 것이다.  
  
즉, Range Scan을 하기 위해서는 인덱스의 선두 컬럼이  
가공되지 않은 상태로 조건절에 있어야 한다.  
  
하지만, 인덱스를 잘 타는 것도 중요하지만 리프 블록에서 스캔하는 양도 중요하다.  
  
## 인덱스를 이용한 소트 연산 생략
인덱스를 사용해서 조회하면 결과집합은 인덱스의 정렬 순서대로 출력되기 때문에  
정렬 연산을 생략할 수 없게 인덱스가 구성되지 않은 경우를 제외하고  
옵티마이저는 SQL에 ORDER BY가 있어도 정렬 연산을 수행하지 않는다.  
  
또한, 리프 블록은 양방향 연결 리스트 구조이기 때문에  
내림차순 정렬도 인덱스를 사용해 정렬 연산을 생략할 수 있다.  
  
오름차순 = 좌측으로 수직적 탐색 + 우측으로 수평적 탐색  
내림차순 = 우측으로 수직적 탐색 + 좌측으로 수평적 탐색  
  
## ORDER BY 절에서 컬럼 가공
인덱스 범위 스캔을 통해 조회한 경우에는 당연히 정렬을 보장하지만  
정렬 기준에 가공된 값이 들어가게 된다면 정렬 연산이 발생한다.  
  
## SELECT-LIST에서 컬럼 가공
인덱스를 사용해 최소, 최대값을 구할 때도 추가적인 정렬 연산은 없지만  
가공된 값을 사용하면 당연히 추가적인 정렬 연산이 발생한다.  
  
## 자동 형변환
오라클은 조건절에서 양쪽 값의 데이터 타입이 다른 경우  
자동 형변환을 사용해 처리하기 때문에 인덱스를 사용할 수 없는 경우가 있다.  
  
데이터 타입마다 다르지만, 자동 형변환 시에도 인덱스를 사용하기 위해서는  
인덱스가 존재하는 좌변 컬럼 기준으로 우변이 변환되는 경우에만 가능하다.  
  
LIKE 검색의 경우에는 문자열 검색이기 때문에  
숫자형 데이터도 문자로 바꿔버리는 것을 주의해야 한다.  
  
자동 형변환은 가급적이면 피하고 인덱스 컬럼을 기준으로  
반대편 컬럼 혹은 값을 정확히 형변환 해주는 것이 중요하다.  
  
형변환 함수를 사용해서 발생하는 연산보다는 블록 I/O를 줄이는 것이 더 중요하고  
형변환 함수를 생략해도 옵티마이저가 자동으로 생성하기 때문에 의미 없다.  
  
# 인덱스 확장기능 사용법
인덱스의 다양한 스캔 방식  
  
## Index Range Scan
BTree 인덱스의 가장 일반적이고 정상적인 형태의 액세스 방식으로,  
루트에서 리프 블록까지 수직적으로 탐색해 시작점을 찾고,  
필요한 범위만 수평적 탐색으로 스캔한다.  
  
## Index Full Scan
데이터 검색을 위한 최적의 인덱스가 없는 경우 사용되는 방식으로,  
수직적 탐색 없이 리프 블록을 처음부터 끝까지 수평적으로 탐색하는 방식이다.  
  
### 효율
옵티마이저는 조건절에 인덱스의 선두 컬럼이 없으면 Table Full Scan을 고려하는데,  
대용량 테이블이라 부담이 크다면 Index Full Scan을 고려한다.  

즉, 인덱스 스캔 단계에서 필터링을 통해 테이블 액세스를 줄일 수 있는 경우라면  
Table Full Scan보다 Index Full Scan이 유리하다.  
  
### 인덱스를 이용한 소트 연산 생략
인덱스를 사용해서 조회한 것이기 때문에 당연히 결과집합도 정렬된 상태기에  
정렬 연산을 생략할 목적으로 사용할 수도 있다.  
  
## Index Unique Scan
수직적 탐색만으로 데이터를 찾는 스캔 방식으로,  
Unique 인덱스를 = 조건으로 탐색하는 경우에만 동작한다.  
  
주의할 점  
- 범위 검색 조건은 Index Range Scan으로 처리된다.  
- 
