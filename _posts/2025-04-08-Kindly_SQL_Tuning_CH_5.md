---
title: "소트 튜닝"
date: 2025-04-08 22:31:33 +/-TTTT
categories: [Book, 친절한 SQL 튜닝]
tags: [SQL, DB, Oracle]
math: true
toc: true
# pin: true
---
## 소트 연산에 대한 이해
### 소트 수행 과정
정렬은 기본적으로 PGA의 Sort Area에서 이루어지고, 메모리 공간이 부족하면 디스크의 Temp 테이블스페이스를 활용하고, Sort Area에서 작업을 완료할 수 있는지에 따라 정렬을 두 가지 유형으로 나눈다.  
  
**In-Memory Sort(Internal Sort)**  
전체 데이터의 정렬 작업을 메모리 내에서 완료  
  
**To-Disk Sort(External Sort)**  
디스크 공간까지 사용해 정렬 작업을 완료  
  
정렬은 다음과 같은 순서로 이루어진다.
1. 정렬 대상 집합을 SGA 버퍼캐시를 통해 읽어들인다.
2. Sort Area에서 정렬을 수행한다.
3. Sort Area가 찰 때마다 정렬된 중간집합을 Temp 테이블스페이스에 임세 세그먼트를 만들어 저장한다.
4. 이러한 중간 단계 집합을 Sort Run이라고 한다.
5. Sort Run을 Merge해서 정렬 최종 결과집합을 얻는다.

즉, 정렬 연산은 메모리와 CPU 집약적인 연산이고, 데이터량이 크다면 디스크 I/O까지 발생해 쿼리 성능에 큰 영향을 미친다. 또한 부분범위 처리도 불가능하기 때문에 OLTP 환경에서 성능 저하의 주요 원인이다.  
  
가능한 정렬 연산이 발생하지 않게 쿼리를 작성하고, 불가피하면 메모리 내에서 처리할 수 있게 해야한다.  
  
### 소트 오퍼레이션
정렬을 발생시키는 연산에 대해 알아보자
  
#### Sort Aggregate
실제로 데이터를 정렬하지 않고 Sort Area를 사용하기만 하는 연산으로, 전체 로우를 대상으로 집계를 수행할 때 나타난다. SUM, MAX, MIN, AVG를 구할 때, (SUM, MAX, MIN, COUNT) 변수를 Sort Area에 생성하고, 테이블의 전체 레코드를 읽어가면서 각 변수에 맞게 값들을 갱신해주면 된다.  
  
테이블의 모든 레코드를 읽은 후 각 변수의 값을 그대로 얻거나, SUM에서 COUNT를 나누면 AVG를 구할 수 있기 때문이다. 즉, 정렬은 없고 Sort Area를 사용하기만 했을 뿐이다.  
  
#### Sort Order By
데이터 정렬 시에 발생하는 연산이다.  
  
#### Sort Group By
정렬 알고리즘을 사용해 그룹별 집계 시 발생하는 연산이다. 그룹핑 후에 그룹별 집계 데이터를 얻는 과정으로, 데이터 정렬이 추가되기만 하고, 집계 데이터를 구하는 방식은 Sort Aggregate와 같다.  
  
Hash Group By 방식도 존재하는데, Group By 절 뒤에 Order By를 명시하지 않으면 오라클 10gR2 버전부터는 대부분 해당 방식으로 처리한다. 그룹별 집계를 기록하는 공간을 찾는데 정렬 알고리즘을 사용하는 것이 아닌 해싱 알고리즘을 사용한다.  
  
또한 그룹핑 결과는 정렬 순서를 보장하지 않는 것을 조심해야 한다.  
  
#### Sort Unique
중복을 제거하기 위해 정렬이 발생하는 것으로 다음과 같은 경우 발생한다.  
- Unnesting 된 서브쿼리가 M쪽 집합인 경우에 중복 레코드를 제거가 필요한 경우
- 집합 연산자(Union, Minus, Intersect)을 사용하는 경우
- Distinct 연산자를 사용하는 경우(Order By 생략 시 Hash Unique 사용)
  
만약 PK 혹은 Unique 제약이나 Unique 인덱스를 통해 유일성이 보장된다면 Sort Unique 오퍼레이션 생략이 가능하다.  
  
#### Sort Join
소트 머지 조인 수행 시 발생한다.  
  
#### Window Sort
윈도우 함수 수행 시 발생한다.  
  
## 소트가 발생하지 않도록 SQL 작성
### Union vs. Union All
Union은 중복 제거를 위해 정렬 작업을 수행하지만, Union All은 중복 제거 없이 결합하기 때문에 정렬이 발생하지 않기에, 가능한 Union All을 사용해야 한다. 이를 위해서는 Union All을 사용해도 괜찮은지 판단하기 위해 데이터 모델에 대한 이해가 필요하다.  
  
### EXIST 활용
중복 제거 시 Distinct 연산자를 사용하면 조건에 해당하는 모든 데이터를 읽은 후 중복을 제거한다. 이러면 부분범위 처리가 불가능하고, 많은 I/O가 발생해 비효율적이다. 반면에 EXIST 서브쿼리는 데이터 존재 여부만 확인해서 조건절을 만족하는 데이터를 모두 읽는 비효율도 없고 부분범위 처리도 가능하다.  
  
Distinct(EXIST), Minus(NOT EXIST) 연산자를 사용한 쿼리는 대부분 EXIST 서브쿼리로 변환가능하다.  
  
### 조인 방식 변경
예를 들어 Hash Join은 정렬을 보장하지 않기에 정렬 사용 시 정렬 연산 생략이 불가능하지만, 인덱스가 있어서 정렬을 생략할 수 있다면 NL 조인을 사용하도록 조인 방식을 변경하면 정렬 연산을 생략할 수 있다. 물론 정렬 기준이 조인 키 컬럼이면 소트 머지 조인도 정렬 연산을 생략할 수 있다.  
  
## 인덱스를 이용한 소트 연산 생략
