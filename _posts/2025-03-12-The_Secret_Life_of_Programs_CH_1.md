---
title: "[한 권으로 읽는 컴퓨터 구조와 프로그래밍] 컴퓨터 내부의 언어 체계"
date: 2025-03-12 09:10:00 +/-TTTT
categories: [Book, 한 권으로 읽는 컴퓨터 구조와 프로그래밍]
tags: [CS]
math: true
toc: true
# pin: true
---
## 언어란
모든 언어의 뜻은 기호의 집합으로 인코딩 되는데  
같은 기호에 대해 같은 문맥을 공유해야 같은 기호에 같은 뜻을 부여할 수 있다.  
  
## 문자 언어
문자 언어 = 기호를 정해진 순서대로 나열한 것  
= 기호가 들어갈 상자 + 상자에 들어갈 기호 + 상자의 순서  
  
## 비트
비트 = 기호가 들어갈 상자 = 문자  
  
bit는 binary + digit으로 2진법을 사용하기에 상자에는 2가지 기호 중 하나만 담을 수 있다.  
  
## 논리 연산
비트는 참과 거짓을 표현할 때 사용할 수 있는데, 이러한 참/거짓 구절을 엮어서  
한 문장으로 만들어 새로운 문장을 만드는  
즉, 다른 비트들이 표현하는 내용으로 새로운 비트를 만들어내는 동작이 논리 연산이다.  
  
### 불리언 대수
비트에 대해 사용할 수 있는 연산 규칙의 집합이다.  
(일반 대수와 마찬 가지로 결합, 교환, 분배 법칙을 적용할 수 있다.)  
  
연산자
- NOT : 논리적 반대를 의미
  ```java
  boolean b = true;
  b = !b;
  ```
- AND : 모든 비트가 참이여야 참
- OR : 한 비트라도 참이면 참
- XOR : 두 비트가 서로 다른 경우에만 참
  
### 드모르간의 법칙
a AND b = NOT(NOT a OR NOT b)  
  
NOT을 충분히 사용하면 AND 연산을 OR 연산으로 대신 할 수 있고,  
반대의 경우에도 OR 연산을 AND 연산으로 대신할 수 있다.  
  
긍정적인 논리에 더해 부정적인 논리를 기술하는 명제를 사용할 때 활용할 수 있다.  
다른 연산을 추가적으로 사용해서 구현할 수도 있지만, 연산을 최소화할 수 있다.  
  
## 정수를 비트로 표현하는 방법
### 양의 정수 표현
10진수 기준 한 상자에는 10개의 기호가 들어갈 수 있으나  
비트는 2진수기에 한 상자에 2개의 기호만 들어갈 수 있기에  
10진수를 비트로 표현할 때는 상자를 늘리기만 하면 된다.  
  
LSB / MSB : 가장 작은/큰 유효 비트로 양쪽 끝의 비트  
  
### 2진수 덧셈
10진수 덧셈이 왼쪽에서 오른쪽으로 값을 더하면서 9보다 커지면 1을 올리는 것처럼  
2진수에서도 비트를 왼쪽에서 오른쪽으로 값을 더하면서 1보다 크면 1을 올린다.  
  
A + B = A AND B + A XOR B  
위와 같이 논리 연산으로 2진수의 덧셈을 처리할 수도 있다.  
두 비트를 더한 결과는 두 비트의 XOR 값이고, 올림은 두 비트를 AND한 값이다.  
  
오버플로 = 사용할 비트의 개수로 표현할 수 없는 경우 = MSB에서 올림이 발생한 경우  
언더플로 = MSB 위쪽에서 1을 빌려오는 경우  
  
오버플로 발생 시 조건 코드 레지스터에 msb에서 발생한 올림값이 오버플로 비트에 담겨져있다.  
  
### 음수 표현
같은 비트 범위라도 MSB를 부호로 사용하고 나머지 비트를 값으로 사용한다는  
문맥이 있다면 양수가 아닌 음수로 표현할 수도 있다. (부호와 크기 표현법)  
  
하지만 0이 양수와 음수로 두 개 존재할 수 있고,  
XOR과 AND 연산 수행 시 정상적인 연산이 수행되지 않아 별도의 연산 로직이 필요하다.  
  
그래서 양수의 모든 비트를 반전(NOT) 시키면 음수가 되는 1의 보수 표현법이 등장하지만  
마찬가지로 0이 두 가지로 표현되고, 덧셈 시 순환 올림 처리가 필요한 문제가 존재한다.  
  
현재는 1의 보수에 1을 더하면 2의 보수가 되는 2의 보수 표현법을 사용한다.  
즉, 양수는 그대로 표현하고, 음수는 반전 후 1을 더하는 방식이다.  
(MSB에서 올림 발생 시 해당 값은 버린다.)  
  
기존 두 가지 방식과는 다르게 0이 유일한 형태로 표현되고 덧셈과 뺄셈이 자연스러워진다.

2의 보수로 표현할 수 있는 값의 범위 = (8비트의 경우) -2^(8-1) ~ 2^(8-1)-1  
  
## 실수를 표현하는 방법
### 고정소수점 표현법
주어진 비트의 절반을 정수, 절반을 소수 부분으로 표현한다.  
= 소수점의 위치가 고정이다.  

정수 표현 방식과 유사하고 연산이 간단하지만,  
고정된 범위 내에서만 표현 가능하고, 메모리 사용이 비효율적이다.  
  
### 부동소수점 표현법
소수점의 위치를 고정하지 않고 이동할 수 있는 방식이다.  
  
가수 : 실수 부분, 정규화된 형태로 소수점 왼쪽에 1만 남기도록 정리  
지수 : 2의 거듭제곱 수  
  
4비트 기준  
가수 = 2.1, 지수 = 11  
10비트 기준  
가수 = 2.5, 지수 = 3  
= 2.5 * 2^3 = 20.0  
  
고정소수점과는 다르게 더 넓은 범위의 수를 표현할 수 있고, 메모리를 효율적으로 사용할 수 있다.  
  
단점  
- 같은 값을 다양한 방법으로 표현 가능해 중복되는 패턴 존재
- 근사값 저장 방식이라 정확도가 떨어질 수 있음
- 큰 숫자의 지수에 맞춰 작은 수가 무시되어 계산시 정밀도가 부족할 수 있음
  
### IEEE 부동소수점 수 표준
현대 컴퓨터의 부동소수점 표준으로 단정도(32비트)와 배정도(64비트) 방식이 있고,  
표준을 따르면 연산의 정확성과 일관성을 유지할 수 있다.  
  
단정도 : 1비트(부호) + 8비트(지수) + 23비트(가수)  
배정도 : 1비트(부호) + 11비트(지수) + 52비트(가수)  
  
## 2진 코드화한 10진수 시스템 (BCD)
4비트를 사용해 10진 숫자를 표현하는 방식이다. (10진수의 각 자리를 4비트로 변환)  
  
10(10진수) = 1100(2진수) = 0001 0010(BCD)  
  
장점  
- 2진수보다 더 직관적이기 때문에 사람에게 익숙하다.  
- 즉, 사람이 읽고 해석하기 쉬워 디지털 디스플레이 장치에서 자주 사용된다.  
  
단점
- 4비트는 16가지 값을 표현할 수 있지만 10가지 값 표현에 사용됨  
- 연산시 별도의 보정이 필요함 (결과값을 BCD로 변경)  
  
과거에 비해 비트 비용이 낮아졌어도 비효율적인 방식이기에 현재는 잘 사용되지 않는다.  
  
## 2진수를 다루는 쉬운 방법
### 8진 표현법
2진수 비트 3개를 8비트 하나로 묶는 표현법  
  
### 16진 표현법
컴퓨터 내부가 8비트의 배수를 사용하기 때문에 현재 많이 사용되는 표현법이다.  
  
8비트의 배수는 4로는 나눠지지만 3비트로는 나누어지지 않기 때문에 4비트로 나누어  
0~9, a~f의 16가지 기호를 사용해 표현한다.  
### 프로그래밍 언어의 진법 표기법
8진수 : 0으로 시작  
10진수 : 일반적인 숫자  
16진수 : 0x로 시작  
2진수 : 0b로 시작  
  
## 비트 그룹의 이름
비트는 사용하기에 너무 작아서 더 큰 단위로 묶어서 사용하는데  
현재는 바이트(8비트)를 표준 단위로 사용한다.  
  
비트 묶음 단위
- Nibble : 4비트
- Byte : 8비트, 기본 단위
- Half Word : 16비트
- Word : 32비트, 컴퓨터가 빠르게 처리할 수 있는 가장 큰 덩어리
- Double Word : 64비트
  
크기 단위  
- KB, MB, GB, TB, ...
- 전통적으로는 밑을 10으로 사용했지만, 2로 사용하는 경우도 있다.
- 그래서 KiB, MiB 같은 단위가 등장했다.  
  
또한, 과거에는 문자 = 바이트로 여겨졌지만,  
현재는 다국어 지원을 위해 여러 바이트로 이뤄진 문자 인코딩도 생겨났다.  
  
## 텍스트 표현
### 아스키 코드
정보 교환을 위한 미국 표준 코드로, 키보드 상의 모든 기호에 대해 7비트 값을 할당했다.  
(키보드 상의 모든 기호라고 했지만, 장치를 제어하기 위한 제어문자들도 포함된다.)  
  
### 다른 표준의 진화
아스키 방식은 결국 영어 이외의 문자를 지원하지 않기 때문에 이를 해결하기 위한 방법들이 등장한다.  
(ISO 표준 확장인 ISO-646, ISO-8859와 각국의 문자 인코딩 방식 등)  
  
### 유니코드 변환 형식 8비트
각국의 서로 다른 문자 인코딩 방식으로 인한 문자 간 호환성을 해결하기 위해 등장한  
전 세계 언어와 기호(이모지 포함)를 통합하는 표준 방식이다.  
  
하지만, 유니코드는 숫자 코드일뿐이기에 컴퓨터에서 사용하려면 인코딩 방식이 필요하고,  
UTF-8, UTF-16, UTF-32 같은 인코딩 방식이 존재한다.  
  
UTF-8
- 가장 많이 사용되는 방식
- 문자마다 가변 바이트를 사용하여 저장
- 기존 아스키에 포함되는 문자는 1바이트로 저장하기에 기존 아스키와 호환됨
  
## 문자를 사용한 수 표현
컴퓨터 사이의 송수신 시 2진 데이터를 보내는 것은 제어 문자와 7비트 환경으로 인해 쉽지 않았다.  
  
### 출력 가능하게 변경한 인코딩(Quoted-Printable)
7비트 통신 환경에서 8비트 데이터를 송수신할 수 있게 해주는 인코딩 방식이다.  
  
= 뒤에 바이트의 각 니블을 표현하는 16진수 2개를 추가해 표현한다.  
- =가 의미를 가지게 되기 때문에 표현하기 위해서는 =3D를 변환해줘야 한다.  
- 줄 끝의 공백과 탭도 변환해줘야 한다. (=20, =09)  
  
### 베이스64 인코딩
QP 인코딩은 1바이트 표현을 위해 3바이트를 사용하는 비효율이 존재하는데  
베이스64 인코딩은 3바이트 데이터를 4개의 문자로 표현하는 방식이다.  
  
1. 3바이트(24비트) > 4조각(6비트)
2. 각 조각 값에 출력 가능한 문자 할당
3. 원본 데이터 길이가 3바이트 배수가 아닐 경우 패딩(=) 추가하여 길이 맞춤
   
### URL 인코딩
URL에서 특별한 의미를 가지는 문자들이 존재하고, 이러한 문자들을 리터럴로 사용하기 위해  
각 문자를 16진수로 변환 후 앞에 %를 붙이는 퍼센트 인코딩 방식을 사용한다.  
  
## 색을 표현하는 방법
컴퓨터 그래픽스에서는 픽셀을 찍어 그림을 만들고, RGB를 조합(가산)하여 색을 만든다.  
  
컴퓨터에서는 24비트를 사용해 색을 표현하는데, 현대 컴퓨터에서는 32비트에 색을 넣어서  
처리하다보니 8비트가 남는 현상이 발생했고, 이를 효율적으로 사용하기 위해 투명도라는게 생겼다.  
### 투명도 추가
각 픽셀에 알파라는 투명도 값을 추가해 투명도를 결정하는 방법  
미리 알파값을 곱해 저장해두어 픽셀을 사용할 때마다 추가적인 연산을 수해하지 않는다.  
  
### 색 인코딩
웹 페이지는 UTF-8 문자의 시퀀스로 구성된 텍스트이기 때문에, 색을 표현하려면 텍스트로 표현해야 한다.  
  
16진 트리플렛
- #rrggbb 형식
- RGB 각각의 8비트 색값을 16진 표기로 변환

## 궁금했던 부분
1. 별도의 하드웨어가 필요하는 것이 어떤 말일까?  
  부호와 크기나 1의 보수 표현법이 위와 같은 이유로 비효율적인데  
  위 표현법들은 연산 시 추가적인 연산이 필요한데 이를 처리하기 위해
  추가적으로 AND, OR 같은 더 많은 게이트를 사용해야 하기 때문에  
  쉽게 구현가능하고 간단한 연산인 XOR이 가능한 회로를 만드는 것이 더 효율적이라는 의미
2. 가변 길이 확장 원리 (UTF-8)
  1바이트에서 4바이트까지 동적으로 확장하는 원리는
  첫 번째 바이트의 MSB를 이용해 문자가 몇 바이트로 이루어졌는지를 표시해서
  몇 바이트를 사용할지 정한 후 나머지 바이트가 앞쪽에 10비트 패턴을 사용해서 연결한다.  
  0xxxxxxx, 110xxxxx, 1110xxxx, 11110xxx 처럼 바이트 표시  
  2~4번째 바이트의 앞쪽을 10xxxxxx 형식으로 표시
3. 2진수, 8진수, 16진수가 대표적으로 사용되는 곳
   2진수 : 하드웨어, 비트 연산, 네트워크(예: 서브넷 마스크)  
   8진수 : 리눅스의 chmod 명령어(예: rwx를 8진수로 표현)  
   16진수 : 메모리 주소(예: 자바에서 객체를 프린트하면 나오는 주소), 암호화 및 해시값
